[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RNA editing report website",
    "section": "",
    "text": "flowchart TB\n  \n \n  \n  A[(Raw data)] --- t1(01.Cleaning notebook) \n  t1 --> B[(Cleaned data)]\n  B --- t2(02A.COTAN analysis src)  --> C[(COTAN obj)]\n  \n  C --- t3(03.COTAN clustering src) --> D[(Clustered COTAN obj)] \n  \n  \n  t3 --> CD[(Seurat obj with COTAN cl.)]\n  \n  CD --> t5(Data exploration + Markers +cluster identification notebook) \n  \n  D --> t5\n  \n  t5 --> G[(Seurat obj with cell id)]\n  t5 --> H[(COTAN obj with cell id)]\n  \n  G -->  t6(Exploration & Conclusion notebook) \n  H --> t6\n  \n  \n  classDef src fill:#66cc33;\n  classDef notebook fill:#cc99ff;\n  \n  class t1,t5,t6 notebook;\n  class t2,t3,t4 src;\n\n\n\n\n\n\n\n\n\nNOTE: in the Crohn disease data set the epithelial cells are already dropped."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "IBD/results/01A_Seurat_import_clean.html",
    "href": "IBD/results/01A_Seurat_import_clean.html",
    "title": "IBD pooled dataset cleaning",
    "section": "",
    "text": "library(stringr)\nlibrary(Seurat)\n\nAttaching SeuratObject\n\n\nAttaching sp\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(RColorBrewer)"
  },
  {
    "objectID": "IBD/results/01A_Seurat_import_clean.html#cell-cycle-score",
    "href": "IBD/results/01A_Seurat_import_clean.html#cell-cycle-score",
    "title": "IBD pooled dataset cleaning",
    "section": "Cell cycle score",
    "text": "Cell cycle score\nA list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat. We can segregate this list into markers of G2/M phase and markers of S phase\n\ns.genes <- cc.genes.updated.2019$s.genes\ns.genes <- c(s.genes,str_to_lower(s.genes))\ng2m.genes <- cc.genes.updated.2019$g2m.genes\ng2m.genes <- c(g2m.genes, str_to_lower(g2m.genes))\nsrat <- CellCycleScoring(srat, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)\n\nWarning: The following features are not present in the object: mcm5, pcna,\ntyms, fen1, mcm7, mcm4, rrm1, ung, gins2, mcm6, cdca7, dtl, prim1, uhrf1, cenpu,\nhells, rfc2, polr1b, nasp, rad51ap1, gmnn, wdr76, slbp, ccne2, ubr7, pold3,\nmsh2, atad2, rad51, rrm2, cdc45, cdc6, exo1, tipin, dscc1, blm, casp8ap2, usp1,\nclspn, pola1, chaf1b, mrpl36, e2f8, not searching for symbol synonyms\n\n\nWarning: The following features are not present in the object: PIMREG, JPT1,\nhmgb2, cdk1, nusap1, ube2c, birc5, tpx2, top2a, ndc80, cks2, nuf2, cks1b, mki67,\ntmpo, cenpf, tacc3, pimreg, smc4, ccnb2, ckap2l, ckap2, aurkb, bub1, kif11,\nanp32e, tubb4b, gtse1, kif20b, hjurp, cdca3, jpt1, cdc20, ttk, cdc25c, kif2c,\nrangap1, ncapd2, dlgap5, cdca2, cdca8, ect2, kif23, hmmr, aurka, psrc1, anln,\nlbr, ckap5, cenpe, ctcf, nek2, g2e3, gas2l3, cbx5, cenpa, not searching for\nsymbol synonyms\n\n# view cell cycle scores and phase assignments\nhead(srat[[]])\n\n                       orig.ident nCount_RNA nFeature_RNA percent.mt percent.rb\nCol_AAACCTGAGATGCGAC.1          1       4379         1199  3.3340945   45.69536\nCol_AAACCTGAGGAATTAC.1          1       4004         1417  0.7742258   37.06294\nCol_AAACCTGCAGATGGGT.1          1       5819         1969  2.6980581   34.47328\nCol_AAACCTGGTTCGGGCT.1          1       4340         1549  4.0783410   33.66359\nCol_AAACCTGGTTTGCATG.1          1       4899         1768  4.4498877   31.72076\nCol_AAACCTGTCACATGCA.1          1       3668         1352  3.1352236   36.55943\n                       RNA_snn_res.0.3 seurat_clusters     S.Score   G2M.Score\nCol_AAACCTGAGATGCGAC.1               3               3 -0.04526088 -0.06738658\nCol_AAACCTGAGGAATTAC.1               3               3 -0.06310393 -0.02992080\nCol_AAACCTGCAGATGGGT.1               3               3 -0.05474959 -0.06798010\nCol_AAACCTGGTTCGGGCT.1               3               3 -0.05709454  0.00728307\nCol_AAACCTGGTTTGCATG.1               5               5 -0.10716761 -0.05199952\nCol_AAACCTGTCACATGCA.1               3               3  0.01237206 -0.09404912\n                       Phase old.ident\nCol_AAACCTGAGATGCGAC.1    G1         3\nCol_AAACCTGAGGAATTAC.1    G1         3\nCol_AAACCTGCAGATGGGT.1    G1         3\nCol_AAACCTGGTTCGGGCT.1   G2M         3\nCol_AAACCTGGTTTGCATG.1    G1         5\nCol_AAACCTGTCACATGCA.1     S         3\n\n\n\nDimPlot(srat, reduction = \"umap\",group.by = \"Phase\")\n\n\n\n\n\nFeaturePlot(srat,features = c(\"S.Score\",\"G2M.Score\"),label.size = 4,repel = T,label = T) & \n  theme(plot.title = element_text(size=10))\n\n\n\n\n\nVlnPlot(srat,features = c(\"S.Score\",\"G2M.Score\"),group.by  = \"seurat_clusters\") & \n  theme(plot.title = element_text(size=10))\n\n\n\n\n“We suggest regressing out the difference between the G2M and S phase scores. This means that signals separating non-cycling cells and cycling cells will be maintained, but differences in cell cycle phase amongst proliferating cells (which are often uninteresting), will be regressed out of the data” From the Seurat official site.\n\nDimPlot(srat, reduction = \"pca\",group.by = \"Phase\")\n\n\n\n\n\n#srat$CC.Difference <- srat$S.Score - srat$G2M.Score\n#srat <- ScaleData(srat, vars.to.regress = \"CC.Difference\", features = rownames(srat))\n\n\nsrat <- readRDS(\"../data/02_cleaned_data/Seurat_colitis_data.RDS\")\n\n\n# Now, a PCA on the variable genes no longer returns components associated with cell cycle\nsrat <- RunPCA(srat, features = VariableFeatures(srat), nfeatures.print = 25)\n\nPC_ 1 \nPositive:  B2M, HLA-A, IFITM1, CD3E, IL32, CD3D, CD7, FYB, CD3G, CD2 \n       LCP2, CCL5, CD247, CD96, ITM2A, RARRES3, GIMAP7, ZFP36L2, HCST, SRGN \n       CST7, LAT, IL2RB, NKG7, S100A4 \nNegative:  RGS13, MEF2B, STMN1, CDCA7, KIAA0101, ELL3, TYMS, RRM2, UBE2C, CDT1 \n       TK1, NUSAP1, BIRC5, POU2AF1, MKI67, MARCKSL1, CCNA2, CDKN3, KIFC1, CCNB2 \n       UHRF1, UBE2J1, CDCA3, TOP2A, TCL1A \nPC_ 2 \nPositive:  HLA-DQA1, HLA-DRA, HLA-DPB1, CD79A, CD74, HLA-DQB1, HLA-DRB1, HLA-DPA1, MS4A1, VPREB3 \n       CD79B, CD83, FCER2, HLA-DRB5, LTB, FCRLA, KLF2, CR2, PHACTR1, TCL1A \n       CD40, IGHM, CD24, GM2A, PLD4 \nNegative:  CD3E, IL32, CD7, CD3D, CCL5, CD3G, HCST, CD247, NKG7, LCP2 \n       CD2, FYB, CD96, CST7, IL2RB, SRGN, RARRES3, GAPDH, FYN, TNFAIP3 \n       KLRD1, PRKCH, GZMM, ITM2A, ID2 \nPC_ 3 \nPositive:  TCF7, CD4, PDCD1, SPOCK2, PASK, IL6R, CD28, CD5, IL6ST, TOX2 \n       TC2N, CTLA4, CD6, ACTN1, LAT, ICOS, GPR183, MAF, CCR7, RRM2 \n       SH2D1A, GIMAP4, FBLN7, CTSB, TYMS \nNegative:  HOPX, NKG7, CCL5, KLRD1, KIR2DL4, GZMA, FCER1G, GSTP1, CD63, ITGA1 \n       GZMB, MYO1E, CST7, LGALS1, PRF1, RHOC, MEF2B, GAPDH, FASLG, CTSW \n       ID2, SH2D1B, TMIGD2, ACTG1, SERPINA9 \nPC_ 4 \nPositive:  HLA-DRB1, HLA-DPA1, FTL, HLA-DPB1, CAPG, FCER2, HLA-DQA1, HLA-DRA, RRM2, TUBA1B \n       CCNA2, TYMS, HLA-DQB1, KLF2, VIM, CDK1, ASF1B, KIFC1, KIR2DL4, PKMYT1 \n       CCL5, UBE2C, KLRD1, CD74, UHRF1 \nNegative:  CD27, PDCD1, MEF2B, PASK, SERPINA9, RGS13, TOX2, CD4, TCF7, LAT \n       CTLA4, ISG20, CORO1B, MAF, DCAF12, IL6R, FKBP5, SH2D1A, ELL3, HMCES \n       ICOS, CD28, ACTG1, TOX, IL6ST \nPC_ 5 \nPositive:  IL4I1, NFKBIA, KIT, IL23R, NR4A1, TNFRSF18, KRT86, TYROBP, ZFP36, LINC00299 \n       CD83, MAP3K8, TNFRSF4, CDKN1A, TNFSF13B, DUSP1, NR4A2, BHLHE40, PHLDA1, AREG \n       BCL2A1, KLF6, KIAA1324, FOS, FOSB \nNegative:  RPL28, GIMAP7, CD8A, GZMM, LEF1, GIMAP4, GIMAP1, CD8B, LINC00861, CD3G \n       CXCR3, CD3D, CCL5, AICDA, NELL2, CD3E, S100A10, RPLP0, FYB, CST7 \n       IFNG-AS1, SUSD3, GZMK, CD27, RPLP1 \n\nDimPlot(srat, reduction = \"pca\",group.by = \"Phase\")\n\n\n\n\n\ngc()\n\n            used   (Mb) gc trigger    (Mb)   max used    (Mb)\nNcells   3466120  185.2    5097011   272.3    5097011   272.3\nVcells 779976759 5950.8 1797224541 13711.8 1793215236 13681.2\n\nsrat <- RunUMAP(srat, dims = 1:25, verbose = F)\nDimPlot(srat, reduction = \"umap\",group.by = \"Phase\")"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html",
    "title": "Cleaning notebook patient 5",
    "section": "",
    "text": "Last compiled"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#import-metadata",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#import-metadata",
    "title": "Cleaning notebook patient 5",
    "section": "Import metadata",
    "text": "Import metadata\n\npatient <- \"patient5_Uninvolved\"\nstatus <- \"Uninvolved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 5\" \n                        & metadata$status == status\n, ,drop = FALSE])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"68 dimension 33694 144813\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5236059 279.7    7998072 427.2  7998072 427.2\nVcells 27125562 207.0   58720586 448.1 58720586 448.1\n\ndim(raw.total)\n\n[1]  33694 144813\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 15770\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  15130 144813\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 15130 78936\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 15130 78936"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#general-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#general-cleaning",
    "title": "Cleaning notebook patient 5",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 10000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDrop cells with less than 30 genes detected\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 1500])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 15130 17471\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n68_AAGACAGACCAATG-1 68_AATGAGGATGGGAG-1 68_ACAACCGATCCTGC-1 68_ACCAGCCTGAGACG-1 \n                 30                  30                  30                  30 \n68_ACCTGGCTCACACA-1 68_ACGTGCCTTTCAGG-1 68_AGATATTGATTCTC-1 68_AGATATTGTGACAC-1 \n                 30                  30                  30                  30 \n68_AGCTCGCTCACAAC-1 68_AGCTTACTTCTATC-1 \n                 30                  30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972010_68\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.5 ileum \",status))\n\nSetting new log level to 1\n\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient5_Uninvolved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 15937\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#cotan-specific-data-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#cotan-specific-data-cleaning",
    "title": "Cleaning notebook patient 5",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5308224 283.5    7998072 427.2  7998072 427.2\nVcells 34856252 266.0   70618528 538.8 70618286 538.8\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [6666] genes and [0] cells\n\nplots <- cleanPlots(obj)\n\nWarning in asMethod(object): sparse->dense coercion: allocating vector of size\n1.0 GiB\n\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,2000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.5, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 13937 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#import-data",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#import-data",
    "title": "Cleaning notebook patient 5",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient5_Involved\"\nstatus <- \"Involved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 5\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"69 dimension 33694 103544\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5402918 288.6    7998072  427.2   7998072  427.2\nVcells 46500628 354.8  265898889 2028.7 431366740 3291.1\n\ndim(raw.total)\n\n[1]  33694 103544\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 16276\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  14551 103544\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 14551 57462\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 14551 57462"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#general-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#general-cleaning-1",
    "title": "Cleaning notebook patient 5",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 20000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2500])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 14551  5156\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n69_AACCCAGAACTACG-1 69_AACGTGTGTAGCGT-1 69_AACTACCTCACTTT-1 69_AAGACAGACCACCT-1 \n                 30                  30                  30                  30 \n69_ACGGTATGGGAGCA-1 69_AGTTATGATTCCGC-1 69_AGTTTCACGAAACA-1 69_AGTTTCACTGGTGT-1 \n                 30                  30                  30                  30 \n69_ATCACTACCAAAGA-1 69_ATCGAGTGTTACTC-1 \n                 30                  30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972009_69\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.5 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient5_Involved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 4957\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#cotan-specific-data-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#cotan-specific-data-cleaning-1",
    "title": "Cleaning notebook patient 5",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5338985 285.2    7998072  427.2   7998072  427.2\nVcells 42101063 321.3  212719112 1623.0 431366740 3291.1\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [3092] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 1159 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#import-data-1",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#import-data-1",
    "title": "Cleaning notebook patient 5",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient5_PBMC\"\nstatus <- \"PBMC\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 5\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"67 dimension 33694 67584\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5358548 286.2    7998072  427.2   7998072  427.2\nVcells 31504640 240.4  136140232 1038.7 431366740 3291.1\n\ndim(raw.total)\n\n[1] 33694 67584\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 21396\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(Matrix::rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  9490 67584\n\n\n\nraw.total <- raw.total[,!Matrix::colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1]  9490 18833\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1]  9490 18833"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#general-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#general-cleaning-2",
    "title": "Cleaning notebook patient 5",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 20)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 20.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 20]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 2000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 10])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 750])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 9490 2967\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n67_CAAAGCTGGTCTAG-1 67_CACCCATGCTAGTG-1 67_CATGTTACTCTCCG-1 67_CCAAGTGACGTGTA-1 \n                 10                  10                  10                  10 \n67_CTCTAAACGATGAA-1 67_CTCTAATGAGCAAA-1 67_CTTGATTGACGGTT-1 67_GCGCACGAGGTTCA-1 \n                 10                  10                  10                  10 \n67_TTACGTACATGCTG-1 67_AAGGTCTGGTCAAC-1 \n                 10                  11 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM4761136_67\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.11 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient5_PBMC\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 2853\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient5_NB.html#cotan-specific-data-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient5_NB.html#cotan-specific-data-cleaning-2",
    "title": "Cleaning notebook patient 5",
    "section": "COTAN-specific data cleaning",
    "text": "COTAN-specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used   (Mb)\nNcells  5288805 282.5    7998072 427.2   7998072  427.2\nVcells 28095727 214.4  108912186 831.0 431366740 3291.1\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [2044] genes and [75] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low. Here the problem is that there seem to be two different cell populations: one with a low amount of RNA and low number of genes and another with a high amount.(Maybe neutrophils?)\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,3000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 1434 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))\n\n\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    stringr_1.4.0     ggrepel_0.9.2    \n[5] ggplot2_3.4.0     Matrix_1.5-1      data.table_1.14.2\n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       viridis_0.6.2         fansi_1.0.3          \n [16] magrittr_2.0.3        memoise_2.0.1         tensor_1.5           \n [19] cluster_2.1.4         doParallel_1.0.17     ROCR_1.0-11          \n [22] remotes_2.4.2         ComplexHeatmap_2.13.0 globals_0.16.2       \n [25] matrixStats_0.63.0    spatstat.sparse_3.0-0 prettyunits_1.1.1    \n [28] colorspace_2.0-3      xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            viridisLite_0.4.0     xtable_1.8-4         \n [58] clue_0.3-61           reticulate_1.25       spatstat.core_2.4-4  \n [61] stats4_4.2.2          htmlwidgets_1.5.4     httr_1.4.4           \n [64] RColorBrewer_1.1-3    ellipsis_0.3.2        Seurat_4.2.0         \n [67] factoextra_1.0.7      ica_1.0-2             farver_2.1.0         \n [70] pkgconfig_2.0.3       uwot_0.1.14           deldir_1.0-6         \n [73] utf8_1.2.2            labeling_0.4.2        tidyselect_1.2.0     \n [76] rlang_1.0.6           reshape2_1.4.4        later_1.3.0          \n [79] cellranger_1.1.0      munsell_0.5.0         tools_4.2.2          \n [82] cachem_1.0.6          cli_3.4.1             gsubfn_0.7           \n [85] generics_0.1.2        devtools_2.4.3        ggridges_0.5.4       \n [88] evaluate_0.18         fastmap_1.1.0         goftest_1.2-3        \n [91] yaml_2.3.5            processx_3.7.0        knitr_1.40           \n [94] fs_1.5.2              fitdistrplus_1.1-8    purrr_0.3.4          \n [97] RANN_2.6.1            dendextend_1.16.0     nlme_3.1-160         \n[100] pbapply_1.6-0         future_1.29.0         mime_0.12            \n[103] brio_1.1.3            compiler_4.2.2        rstudioapi_0.13      \n[106] plotly_4.10.0         png_0.1-7             spatstat.utils_3.0-1 \n[109] tibble_3.1.7          stringi_1.7.6         ps_1.7.0             \n[112] desc_1.4.1            rgeos_0.5-9           lattice_0.20-45      \n[115] vctrs_0.5.0           pillar_1.8.1          lifecycle_1.0.3      \n[118] spatstat.geom_3.0-3   lmtest_0.9-40         GlobalOptions_0.1.2  \n[121] RcppAnnoy_0.0.19      cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    gridExtra_2.3        \n[130] IRanges_2.31.2        parallelly_1.32.1     sessioninfo_1.2.2    \n[133] codetools_0.2-18      MASS_7.3-58           assertthat_0.2.1     \n[136] pkgload_1.3.0         proto_1.0.0           rprojroot_2.0.3      \n[139] rjson_0.2.21          withr_2.5.0           SeuratObject_4.1.2   \n[142] sctransform_0.3.5     S4Vectors_0.35.0      mgcv_1.8-41          \n[145] parallel_4.2.2        rpart_4.1.19          grid_4.2.2           \n[148] tidyr_1.2.0           rmarkdown_2.17        Rfast_2.0.6          \n[151] Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html",
    "title": "Cleaning notebook patient 7",
    "section": "",
    "text": "Last compiled"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#import-metadata",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#import-metadata",
    "title": "Cleaning notebook patient 7",
    "section": "Import metadata",
    "text": "Import metadata\n\npatient <- \"patient7_Uninvolved\"\nstatus <- \"Uninvolved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 7\" \n                        & metadata$status == status\n, ,drop = FALSE])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"129 dimension 33694 81564\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5172811 276.3   11115520 593.7  7998075 427.2\nVcells 21545323 164.4   41181593 314.2 41120438 313.8\n\ndim(raw.total)\n\n[1] 33694 81564\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 15860\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1] 14636 81564\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 14636 59340\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 14636 59340"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#general-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#general-cleaning",
    "title": "Cleaning notebook patient 7",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 7500]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDrop cells with less than 30 genes detected\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 1700])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 14636  4360\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n129_AGACGTTGTACTCGCG-1 129_AGACGTTTCTCTTATG-1 129_AGTTGGTGTAGCCTCG-1 \n                    30                     30                     30 \n129_CACAAACAGGACGAAA-1 129_CCGTGGACAGTTCATG-1 129_CGAACATGTGTTGAGG-1 \n                    30                     30                     30 \n129_CGTAGGCTCTTGAGGT-1 129_CGTTGGGGTATAGGGC-1 129_CTAGAGTAGGCTACGA-1 \n                    30                     30                     30 \n129_CTAGTGAAGAAGAAGC-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972014_129\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.7 ileum \",status))\n\nSetting new log level to 1\n\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient7_Uninvolved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 3129\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#cotan-specific-data-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#cotan-specific-data-cleaning",
    "title": "Cleaning notebook patient 7",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5288201 282.5   11115520 593.7  9257346 494.4\nVcells 24032633 183.4   49497911 377.7 49497039 377.7\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [3349] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,2000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.5, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 1639 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#import-data",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#import-data",
    "title": "Cleaning notebook patient 7",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient7_Involved\"\nstatus <- \"Involved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 7\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"128 dimension 33694 88054\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5374499 287.1   11115520 593.7 11115520 593.7\nVcells 31151624 237.7   80950986 617.7 79045039 603.1\n\ndim(raw.total)\n\n[1] 33694 88054\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 15047\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1] 15560 88054\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 15560 56719\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 15560 56719"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#general-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#general-cleaning-1",
    "title": "Cleaning notebook patient 7",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 20000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 3000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 15560  4741\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n128_AACCATGGTTCCAACA-1 128_ACAGCCGGTTACGGAG-1 128_ACTGAGTCACATGGGA-1 \n                    30                     30                     30 \n128_ACTTACTAGCTAGGCA-1 128_AGAATAGGTTAAGACA-1 128_AGAGCTTAGTCAAGGC-1 \n                    30                     30                     30 \n128_AGCGGTCTCACCCTCA-1 128_AGTGGGACAAATTGCC-1 128_CAACTAGTCACATACG-1 \n                    30                     30                     30 \n128_CAAGGCCAGCCATCGC-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972013_128\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.7 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient7_Involved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 4076\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#cotan-specific-data-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#cotan-specific-data-cleaning-1",
    "title": "Cleaning notebook patient 7",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5326387 284.5   11115520 593.7 11115520 593.7\nVcells 32222772 245.9   80950986 617.7 80700549 615.7\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [3253] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 1071 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#import-data-1",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#import-data-1",
    "title": "Cleaning notebook patient 7",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient7_PBMC\"\nstatus <- \"PBMC\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 7\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"127 dimension 33694 50914\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5340990 285.3   11115520 593.7 11115520 593.7\nVcells 31981401 244.0  102212088 779.9 96452116 735.9\n\ndim(raw.total)\n\n[1] 33694 50914\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 17858\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(Matrix::rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1] 12713 50914\n\n\n\nraw.total <- raw.total[,!Matrix::colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 12713  5263\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 12713  5263"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#general-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#general-cleaning-2",
    "title": "Cleaning notebook patient 7",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 20)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 20.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 20]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 10000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 20])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 12713  1594\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n127_ACGATGTTCCACGAAT-1 127_AGAGCTTAGAGTAAGG-1 127_ATCATCTGTCTTGTCC-1 \n                    20                     20                     20 \n127_ATTGGTGAGTTCGCAT-1 127_CAGTAACCAAACCTAC-1 127_CGCGTTTTCCCTTGTG-1 \n                    20                     20                     20 \n127_CGTCTACCAAACGCGA-1 127_GGACGTCCATCCAACA-1 127_TAAACCGGTCCAGTGC-1 \n                    20                     20                     20 \n127_TACTCATCAAGCGCTC-1 \n                    20 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM4761138_127\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.11 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient7_PBMC\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 1569\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient7_NB.html#cotan-specific-data-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient7_NB.html#cotan-specific-data-cleaning-2",
    "title": "Cleaning notebook patient 7",
    "section": "COTAN-specific data cleaning",
    "text": "COTAN-specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5276335 281.8   11115520 593.7 11115520 593.7\nVcells 29405990 224.4  102212088 779.9 96452116 735.9\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [576] genes and [100] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low. Here the problem is that there seem to be two different cell populations: one with a low amount of RNA and low number of genes and another with a high amount.(Maybe neutrophils?)\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,3000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 776 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))\n\n\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    stringr_1.4.0     ggrepel_0.9.2    \n[5] ggplot2_3.4.0     Matrix_1.5-1      data.table_1.14.2\n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       viridis_0.6.2         fansi_1.0.3          \n [16] magrittr_2.0.3        memoise_2.0.1         tensor_1.5           \n [19] cluster_2.1.4         doParallel_1.0.17     ROCR_1.0-11          \n [22] remotes_2.4.2         ComplexHeatmap_2.13.0 globals_0.16.2       \n [25] matrixStats_0.63.0    spatstat.sparse_3.0-0 prettyunits_1.1.1    \n [28] colorspace_2.0-3      xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            viridisLite_0.4.0     xtable_1.8-4         \n [58] clue_0.3-61           reticulate_1.25       spatstat.core_2.4-4  \n [61] stats4_4.2.2          htmlwidgets_1.5.4     httr_1.4.4           \n [64] RColorBrewer_1.1-3    ellipsis_0.3.2        Seurat_4.2.0         \n [67] factoextra_1.0.7      ica_1.0-2             farver_2.1.0         \n [70] pkgconfig_2.0.3       uwot_0.1.14           deldir_1.0-6         \n [73] utf8_1.2.2            labeling_0.4.2        tidyselect_1.2.0     \n [76] rlang_1.0.6           reshape2_1.4.4        later_1.3.0          \n [79] cellranger_1.1.0      munsell_0.5.0         tools_4.2.2          \n [82] cachem_1.0.6          cli_3.4.1             gsubfn_0.7           \n [85] generics_0.1.2        devtools_2.4.3        ggridges_0.5.4       \n [88] evaluate_0.18         fastmap_1.1.0         goftest_1.2-3        \n [91] yaml_2.3.5            processx_3.7.0        knitr_1.40           \n [94] fs_1.5.2              fitdistrplus_1.1-8    purrr_0.3.4          \n [97] RANN_2.6.1            dendextend_1.16.0     nlme_3.1-160         \n[100] pbapply_1.6-0         future_1.29.0         mime_0.12            \n[103] brio_1.1.3            compiler_4.2.2        rstudioapi_0.13      \n[106] plotly_4.10.0         png_0.1-7             spatstat.utils_3.0-1 \n[109] tibble_3.1.7          stringi_1.7.6         ps_1.7.0             \n[112] desc_1.4.1            rgeos_0.5-9           lattice_0.20-45      \n[115] vctrs_0.5.0           pillar_1.8.1          lifecycle_1.0.3      \n[118] spatstat.geom_3.0-3   lmtest_0.9-40         GlobalOptions_0.1.2  \n[121] RcppAnnoy_0.0.19      cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    gridExtra_2.3        \n[130] IRanges_2.31.2        parallelly_1.32.1     sessioninfo_1.2.2    \n[133] codetools_0.2-18      MASS_7.3-58           assertthat_0.2.1     \n[136] pkgload_1.3.0         proto_1.0.0           rprojroot_2.0.3      \n[139] rjson_0.2.21          withr_2.5.0           SeuratObject_4.1.2   \n[142] sctransform_0.3.5     S4Vectors_0.35.0      mgcv_1.8-41          \n[145] parallel_4.2.2        rpart_4.1.19          grid_4.2.2           \n[148] tidyr_1.2.0           rmarkdown_2.17        Rfast_2.0.6          \n[151] Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html",
    "title": "Cleaning notebook patient 8",
    "section": "",
    "text": "Last compiled"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#import-metadata",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#import-metadata",
    "title": "Cleaning notebook patient 8",
    "section": "Import metadata",
    "text": "Import metadata\n\npatient <- \"patient8_Uninvolved\"\nstatus <- \"Uninvolved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 8\" \n                        & metadata$status == status\n, ,drop = FALSE])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"135 dimension 33694 90114\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5181352 276.8   11217754 599.1  7998055 427.2\nVcells 23460334 179.0   54793462 418.1 45594551 347.9\n\ndim(raw.total)\n\n[1] 33694 90114\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 14884\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1] 15615 90114\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 15615 65374\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 15615 65374"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#general-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#general-cleaning",
    "title": "Cleaning notebook patient 8",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 7500]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDrop cells with less than 30 genes detected\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 15615  6901\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n135_ACGCAGCGTTCGTTGA-1 135_CAACCTCTCAACACCA-1 135_CAAGAAAAGTGGTCCC-1 \n                    30                     30                     30 \n135_CAAGATCAGATCCCGC-1 135_CAAGTTGGTCTAAACC-1 135_CAGAATCAGTGACTCT-1 \n                    30                     30                     30 \n135_CATCCACCACATGGGA-1 135_CCTACCACAGACGCCT-1 135_CCTACCACATTACGAC-1 \n                    30                     30                     30 \n135_CGAGCCACAACACGCC-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972015_135\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.8 ileum \",status))\n\nSetting new log level to 1\n\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient8_Uninvolved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 4283\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#cotan-specific-data-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#cotan-specific-data-cleaning",
    "title": "Cleaning notebook patient 8",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5295148 282.8   11217754 599.1 10096053 539.2\nVcells 26450554 201.9   65832154 502.3 65832154 502.3\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [5118] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,2000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.5, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 2283 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#import-data",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#import-data",
    "title": "Cleaning notebook patient 8",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient8_Involved\"\nstatus <- \"Involved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 8\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"138 dimension 33694 91293\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5378864 287.3   11217754 599.1 11217754 599.1\nVcells 32695468 249.5   96905877 739.4 96639207 737.3\n\ndim(raw.total)\n\n[1] 33694 91293\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 15116\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1] 15311 91293\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 15311 70876\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 15311 70876"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#general-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#general-cleaning-1",
    "title": "Cleaning notebook patient 8",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 10000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 15311  5732\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n138_ACATACGGTAAGTGTA-1 138_ACCGTAACACGAGGTA-1 138_ACGCCAGGTACCATCA-1 \n                    30                     30                     30 \n138_ATAACGCAGATATACG-1 138_ATCCGAAGTCTTCAAG-1 138_ATCTGCCCATTAGCCA-1 \n                    30                     30                     30 \n138_ATGTGTGGTGAGGGAG-1 138_ATTGGTGAGCTAGGCA-1 138_CAAGTTGTCGTCCAGG-1 \n                    30                     30                     30 \n138_CAGAATCTCTGAGTGT-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972016_138\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.8 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient8_Involved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 5201\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#cotan-specific-data-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#cotan-specific-data-cleaning-1",
    "title": "Cleaning notebook patient 8",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5341431 285.3   11217754 599.1 11217754 599.1\nVcells 33542852 256.0   96905877 739.4 96756503 738.2\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [4632] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 2045 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#import-data-1",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#import-data-1",
    "title": "Cleaning notebook patient 8",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient8_PBMC\"\nstatus <- \"PBMC\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 8\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"134 dimension 33694 94085\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  5385268 287.7   11217754 599.1  11217754 599.1\nVcells 32969107 251.6  103856932 792.4 108117638 824.9\n\ndim(raw.total)\n\n[1] 33694 94085\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 17792\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(Matrix::rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1] 12542 94085\n\n\n\nraw.total <- raw.total[,!Matrix::colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 12542 58478\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 12542 58478"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#general-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#general-cleaning-2",
    "title": "Cleaning notebook patient 8",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 5000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 1500])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 12542  5769\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n134_AAACCTGTCCAGATCA-1 134_AAATGCCGTATCTGCA-1 134_AACTCCCCACAACGTT-1 \n                    30                     30                     30 \n134_AACTGGTGTATATCCG-1 134_AAGCCGCGTTTACTCT-1 134_AAGGAGCGTGACGCCT-1 \n                    30                     30                     30 \n134_AAGGCAGGTAACGCGA-1 134_AATCCAGTCGGCGGTT-1 134_ACACCAACATGGGAAC-1 \n                    30                     30                     30 \n134_ACAGCTACACATGTGT-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM4761139_134\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.11 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient8_PBMC\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 5695\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient8_NB.html#cotan-specific-data-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient8_NB.html#cotan-specific-data-cleaning-2",
    "title": "Cleaning notebook patient 8",
    "section": "COTAN-specific data cleaning",
    "text": "COTAN-specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  5329639 284.7   11217754 599.1  11217754 599.1\nVcells 30552463 233.1  103856932 792.4 108117638 824.9\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [3895] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low. Here the problem is that there seem to be two different cell populations: one with a low amount of RNA and low number of genes and another with a high amount.(Maybe neutrophils?)\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,3000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 2695 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))\n\n\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    stringr_1.4.0     ggrepel_0.9.2    \n[5] ggplot2_3.4.0     Matrix_1.5-1      data.table_1.14.2\n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       viridis_0.6.2         fansi_1.0.3          \n [16] magrittr_2.0.3        memoise_2.0.1         tensor_1.5           \n [19] cluster_2.1.4         doParallel_1.0.17     ROCR_1.0-11          \n [22] remotes_2.4.2         ComplexHeatmap_2.13.0 globals_0.16.2       \n [25] matrixStats_0.63.0    spatstat.sparse_3.0-0 prettyunits_1.1.1    \n [28] colorspace_2.0-3      xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            viridisLite_0.4.0     xtable_1.8-4         \n [58] clue_0.3-61           reticulate_1.25       spatstat.core_2.4-4  \n [61] stats4_4.2.2          htmlwidgets_1.5.4     httr_1.4.4           \n [64] RColorBrewer_1.1-3    ellipsis_0.3.2        Seurat_4.2.0         \n [67] factoextra_1.0.7      ica_1.0-2             farver_2.1.0         \n [70] pkgconfig_2.0.3       uwot_0.1.14           deldir_1.0-6         \n [73] utf8_1.2.2            labeling_0.4.2        tidyselect_1.2.0     \n [76] rlang_1.0.6           reshape2_1.4.4        later_1.3.0          \n [79] cellranger_1.1.0      munsell_0.5.0         tools_4.2.2          \n [82] cachem_1.0.6          cli_3.4.1             gsubfn_0.7           \n [85] generics_0.1.2        devtools_2.4.3        ggridges_0.5.4       \n [88] evaluate_0.18         fastmap_1.1.0         goftest_1.2-3        \n [91] yaml_2.3.5            processx_3.7.0        knitr_1.40           \n [94] fs_1.5.2              fitdistrplus_1.1-8    purrr_0.3.4          \n [97] RANN_2.6.1            dendextend_1.16.0     nlme_3.1-160         \n[100] pbapply_1.6-0         future_1.29.0         mime_0.12            \n[103] brio_1.1.3            compiler_4.2.2        rstudioapi_0.13      \n[106] plotly_4.10.0         png_0.1-7             spatstat.utils_3.0-1 \n[109] tibble_3.1.7          stringi_1.7.6         ps_1.7.0             \n[112] desc_1.4.1            rgeos_0.5-9           lattice_0.20-45      \n[115] vctrs_0.5.0           pillar_1.8.1          lifecycle_1.0.3      \n[118] spatstat.geom_3.0-3   lmtest_0.9-40         GlobalOptions_0.1.2  \n[121] RcppAnnoy_0.0.19      cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    gridExtra_2.3        \n[130] IRanges_2.31.2        parallelly_1.32.1     sessioninfo_1.2.2    \n[133] codetools_0.2-18      MASS_7.3-58           assertthat_0.2.1     \n[136] pkgload_1.3.0         proto_1.0.0           rprojroot_2.0.3      \n[139] rjson_0.2.21          withr_2.5.0           SeuratObject_4.1.2   \n[142] sctransform_0.3.5     S4Vectors_0.35.0      mgcv_1.8-41          \n[145] parallel_4.2.2        rpart_4.1.19          grid_4.2.2           \n[148] tidyr_1.2.0           rmarkdown_2.17        Rfast_2.0.6          \n[151] Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html",
    "title": "Cleaning notebook patient 10",
    "section": "",
    "text": "Last compiled"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#import-datmeta",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#import-datmeta",
    "title": "Cleaning notebook patient 10",
    "section": "Import datmeta",
    "text": "Import datmeta\n\npatient <- \"patient10_Uninvolved\"\nstatus <- \"Uninvolved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 10\" \n                        & metadata$status == status\n, ,drop = FALSE])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"159 dimension 33694 101395\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5192642 277.4    7998080 427.2  7998080 427.2\nVcells 26849419 204.9   59547237 454.4 59547237 454.4\n\ndim(raw.total)\n\n[1]  33694 101395\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 13791\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  16804 101395\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 16804 69370\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 16804 69370"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#general-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#general-cleaning",
    "title": "Cleaning notebook patient 10",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 50)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 50.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 50]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 8000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDrop cells with less than 30 genes detected\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 16804 10950\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n159_ACTGATGTCTGTCAAG-1 159_CAACCTCGTCGTTGTA-1 159_TTCTCCTAGCCGGTAA-1 \n                    30                     30                     30 \n159_AGTTGGTCATCGTCGG-1 159_ATCATGGTCCGTAGGC-1 159_CGATGGCGTTTGGGCC-1 \n                    31                     31                     31 \n159_GGGTTGCAGACCTAGG-1 159_GTAGGCCCAAGGTGTG-1 159_TTTCCTCCACGACGAA-1 \n                    32                     32                     32 \n159_ACGGCCACATTAGCCA-1 \n                    33 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972018_159\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.10 ileum \",status))\n\nSetting new log level to 1\n\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient10_Uninvolved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 5318\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#cotan-specific-data-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#cotan-specific-data-cleaning",
    "title": "Cleaning notebook patient 10",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5300442 283.1    7998080 427.2  7998080 427.2\nVcells 30317839 231.4   71536684 545.8 71536671 545.8\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [5782] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,2000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.5, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 3318 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#import-data",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#import-data",
    "title": "Cleaning notebook patient 10",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient10_Involved\"\nstatus <- \"Involved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 10\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"158 dimension 33694 108979\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  5397705 288.3    7998080 427.2   7998080 427.2\nVcells 36948994 281.9  119458385 911.4 119458383 911.4\n\ndim(raw.total)\n\n[1]  33694 108979\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 13894\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  16781 108979\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 16781 67450\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 16781 67450"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#general-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#general-cleaning-1",
    "title": "Cleaning notebook patient 10",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 15000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 16781  7887\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n158_AAACGGGAGTCCCACG-1 158_AAAGCAATCGGCGGTT-1 158_AACCATGAGGACCACA-1 \n                    30                     30                     30 \n158_AACTCCCAGTAGGTGC-1 158_ACACCCTTCCGTCATC-1 158_ACCGTAATCGTTTGCC-1 \n                    30                     30                     30 \n158_ACGATGTCAATAGAGT-1 158_ACTATCTTCAGAGACG-1 158_ACTGTCCTCCATGAAC-1 \n                    30                     30                     30 \n158_AGAGCTTGTCAGAGGT-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972017_158\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.10 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient10_Involved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 4796\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#cotan-specific-data-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#cotan-specific-data-cleaning-1",
    "title": "Cleaning notebook patient 10",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  5340534 285.3    7998080 427.2   7998080 427.2\nVcells 36960799 282.0  119458385 911.4 119458383 911.4\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [5168] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 1201 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#import-data-1",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#import-data-1",
    "title": "Cleaning notebook patient 10",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient10_PBMC\"\nstatus <- \"PBMC\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 10\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"157 dimension 33694 84520\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  5375598 287.1    7998080 427.2   7998080 427.2\nVcells 35890347 273.9  119458385 911.4 119458383 911.4\n\ndim(raw.total)\n\n[1] 33694 84520\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 16101\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(Matrix::rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1] 14527 84520\n\n\n\nraw.total <- raw.total[,!Matrix::colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 14527 70926\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 14527 70926"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#general-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#general-cleaning-2",
    "title": "Cleaning notebook patient 10",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 40)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 40.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 40]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 7500]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 14527  5073\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n157_ATTGGTGGTCAAAGCG-1 157_CGATTGAGTAACGACG-1 157_CGCGGTAGTGCAACGA-1 \n                    30                     30                     30 \n157_CGGCTAGTCGGTCTAA-1 157_CTCTGGTAGATCGATA-1 157_GATGAGGCAAGTAGTA-1 \n                    30                     30                     30 \n157_GGTGCGTGTGTTAAGA-1 157_TCCACACAGGTGATAT-1 157_TGCCCTATCATGTCCC-1 \n                    30                     30                     30 \n157_ACGCAGCGTCGCGTGT-1 \n                    31 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM4761140_157\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.10 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient10_PBMC\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 4866\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient10_NB.html#cotan-specific-data-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient10_NB.html#cotan-specific-data-cleaning-2",
    "title": "Cleaning notebook patient 10",
    "section": "COTAN-specific data cleaning",
    "text": "COTAN-specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  5343718 285.4    7998080 427.2   7998080 427.2\nVcells 36580384 279.1  119458385 911.4 119458383 911.4\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [2970] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low. Here the problem is that there seem to be two different cell populations: one with a low amount of RNA and low number of genes and another with a high amount.(Maybe neutrophils?)\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,3000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 2702 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))\n\n\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    stringr_1.4.0     ggrepel_0.9.2    \n[5] ggplot2_3.4.0     Matrix_1.5-1      data.table_1.14.2\n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       viridis_0.6.2         fansi_1.0.3          \n [16] magrittr_2.0.3        memoise_2.0.1         tensor_1.5           \n [19] cluster_2.1.4         doParallel_1.0.17     ROCR_1.0-11          \n [22] remotes_2.4.2         ComplexHeatmap_2.13.0 globals_0.16.2       \n [25] matrixStats_0.63.0    spatstat.sparse_3.0-0 prettyunits_1.1.1    \n [28] colorspace_2.0-3      xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            viridisLite_0.4.0     xtable_1.8-4         \n [58] clue_0.3-61           reticulate_1.25       spatstat.core_2.4-4  \n [61] stats4_4.2.2          htmlwidgets_1.5.4     httr_1.4.4           \n [64] RColorBrewer_1.1-3    ellipsis_0.3.2        Seurat_4.2.0         \n [67] factoextra_1.0.7      ica_1.0-2             farver_2.1.0         \n [70] pkgconfig_2.0.3       uwot_0.1.14           deldir_1.0-6         \n [73] utf8_1.2.2            labeling_0.4.2        tidyselect_1.2.0     \n [76] rlang_1.0.6           reshape2_1.4.4        later_1.3.0          \n [79] cellranger_1.1.0      munsell_0.5.0         tools_4.2.2          \n [82] cachem_1.0.6          cli_3.4.1             gsubfn_0.7           \n [85] generics_0.1.2        devtools_2.4.3        ggridges_0.5.4       \n [88] evaluate_0.18         fastmap_1.1.0         goftest_1.2-3        \n [91] yaml_2.3.5            processx_3.7.0        knitr_1.40           \n [94] fs_1.5.2              fitdistrplus_1.1-8    purrr_0.3.4          \n [97] RANN_2.6.1            dendextend_1.16.0     nlme_3.1-160         \n[100] pbapply_1.6-0         future_1.29.0         mime_0.12            \n[103] brio_1.1.3            compiler_4.2.2        rstudioapi_0.13      \n[106] plotly_4.10.0         png_0.1-7             spatstat.utils_3.0-1 \n[109] tibble_3.1.7          stringi_1.7.6         ps_1.7.0             \n[112] desc_1.4.1            rgeos_0.5-9           lattice_0.20-45      \n[115] vctrs_0.5.0           pillar_1.8.1          lifecycle_1.0.3      \n[118] spatstat.geom_3.0-3   lmtest_0.9-40         GlobalOptions_0.1.2  \n[121] RcppAnnoy_0.0.19      cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    gridExtra_2.3        \n[130] IRanges_2.31.2        parallelly_1.32.1     sessioninfo_1.2.2    \n[133] codetools_0.2-18      MASS_7.3-58           assertthat_0.2.1     \n[136] pkgload_1.3.0         proto_1.0.0           rprojroot_2.0.3      \n[139] rjson_0.2.21          withr_2.5.0           SeuratObject_4.1.2   \n[142] sctransform_0.3.5     S4Vectors_0.35.0      mgcv_1.8-41          \n[145] parallel_4.2.2        rpart_4.1.19          grid_4.2.2           \n[148] tidyr_1.2.0           rmarkdown_2.17        Rfast_2.0.6          \n[151] Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html",
    "title": "Cleaning notebook patient 11",
    "section": "",
    "text": "Last compiled"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#import-datmeta",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#import-datmeta",
    "title": "Cleaning notebook patient 11",
    "section": "Import datmeta",
    "text": "Import datmeta\n\npatient <- \"patient11_Uninvolved\"\nstatus <- \"Uninvolved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 11\" \n                        & metadata$status == status\n, ,drop = FALSE])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"180 dimension 33694 104284\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5195552 277.5   11217791 599.1  7998037 427.2\nVcells 24294756 185.4   57053585 435.3 47447363 362.0\n\ndim(raw.total)\n\n[1]  33694 104284\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 14285\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  16462 104284\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 16462 48707\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 16462 48707"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#general-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#general-cleaning",
    "title": "Cleaning notebook patient 11",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 20000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nDrop cells with less than 30 genes detected\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 3000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 16462  4640\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n180_ACAGCCGAGCACACAG-1 180_ACAGCTAAGAACTGTA-1 180_AGACGTTTCCTATTCA-1 \n                    30                     30                     30 \n180_AGAGCTTTCTGCCCTA-1 180_AGCGTCGCATGGGAAC-1 180_ATAGACCAGGATGGTC-1 \n                    30                     30                     30 \n180_CACCACTCATTGGTAC-1 180_CCGTACTAGCTAAGAT-1 180_CTCACACCAATGGATA-1 \n                    30                     30                     30 \n180_GATCGCGTCCAAGTAC-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972019_180\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.11 ileum \",status))\n\nSetting new log level to 1\n\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient11_Uninvolved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 3283\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#cotan-specific-data-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#cotan-specific-data-cleaning",
    "title": "Cleaning notebook patient 11",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5279355 282.0   11217791 599.1 10005193 534.4\nVcells 27945052 213.3   57053585 435.3 57053476 435.3\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [3398] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,2000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.5, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 1283 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#import-data",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#import-data",
    "title": "Cleaning notebook patient 11",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient11_Involved\"\nstatus <- \"Involved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 11\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"181 dimension 33694 119942\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5406645 288.8   11217791 599.1 11217791 599.1\nVcells 40930986 312.3   99383325 758.3 99102578 756.1\n\ndim(raw.total)\n\n[1]  33694 119942\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 14342\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  16526 119942\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 16526 56589\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 16526 56589"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#general-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#general-cleaning-1",
    "title": "Cleaning notebook patient 11",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 10000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 16526 12802\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n181_AAAGTAGCAGATCTGT-1 181_AAGGAGCGTGTCAATC-1 181_ACGGGTCAGTGGGTTG-1 \n                    30                     30                     30 \n181_ACTTGTTGTACTCTCC-1 181_AGCATACGTAAGTGGC-1 181_AGCTCTCCAGACAGGT-1 \n                    30                     30                     30 \n181_ATCGAGTTCCAAGCCG-1 181_ATCTACTGTATTAGCC-1 181_ATCTGCCGTCTGGTCG-1 \n                    30                     30                     30 \n181_ATGAGGGAGGTGTTAA-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972020_181\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.11 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient11_Involved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 12263\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#cotan-specific-data-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#cotan-specific-data-cleaning-1",
    "title": "Cleaning notebook patient 11",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  5327340 284.6   11217791 599.1  11217791 599.1\nVcells 45970469 350.8  119339990 910.5 119337176 910.5\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [5977] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 4263 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#import-data-1",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#import-data-1",
    "title": "Cleaning notebook patient 11",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient11_PBMC\"\nstatus <- \"PBMC\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 11\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"179 dimension 33694 108932\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5407220 288.8   11217791  599.1  11217791  599.1\nVcells 54496149 415.8  179260122 1367.7 290288562 2214.8\n\ndim(raw.total)\n\n[1]  33694 108932\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 16001\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(Matrix::rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  14888 108932\n\n\n\nraw.total <- raw.total[,!Matrix::colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 14888 62555\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 14888 62555"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#general-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#general-cleaning-2",
    "title": "Cleaning notebook patient 11",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 10000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 14888  5755\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 10,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 7500]))\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n179_AAACGGGGTGCCTGGT-1 179_ACACTGACACGACGAA-1 179_ACACTGATCTTCATGT-1 \n                    30                     30                     30 \n179_ACATGGTAGAGTTGGC-1 179_ACCGTAATCTCTGCTG-1 179_ACGATGTCAATCGGTT-1 \n                    30                     30                     30 \n179_ACGCAGCCACTGTCGG-1 179_ACGGCCAAGTATCGAA-1 179_ACGGCCATCTTGTACT-1 \n                    30                     30                     30 \n179_ACTGAGTAGCAGCGTA-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM4761141_179\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.11 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient11_PBMC\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 5432\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient11_NB.html#cotan-specific-data-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient11_NB.html#cotan-specific-data-cleaning-2",
    "title": "Cleaning notebook patient 11",
    "section": "COTAN-specific data cleaning",
    "text": "COTAN-specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5342860 285.4   11217791  599.1  11217791  599.1\nVcells 57793820 441.0  179260122 1367.7 290288562 2214.8\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [3036] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low. Here the problem is that there seem to be two different cell populations: one with a low amount of RNA and low number of genes and another with a high amount.(Maybe neutrophils?)\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,3000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 2876 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))\n\n\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    stringr_1.4.0     ggrepel_0.9.2    \n[5] ggplot2_3.4.0     Matrix_1.5-1      data.table_1.14.2\n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       viridis_0.6.2         fansi_1.0.3          \n [16] magrittr_2.0.3        memoise_2.0.1         tensor_1.5           \n [19] cluster_2.1.4         doParallel_1.0.17     ROCR_1.0-11          \n [22] remotes_2.4.2         ComplexHeatmap_2.13.0 globals_0.16.2       \n [25] matrixStats_0.63.0    spatstat.sparse_3.0-0 prettyunits_1.1.1    \n [28] colorspace_2.0-3      xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            viridisLite_0.4.0     xtable_1.8-4         \n [58] clue_0.3-61           reticulate_1.25       spatstat.core_2.4-4  \n [61] stats4_4.2.2          htmlwidgets_1.5.4     httr_1.4.4           \n [64] RColorBrewer_1.1-3    ellipsis_0.3.2        Seurat_4.2.0         \n [67] factoextra_1.0.7      ica_1.0-2             farver_2.1.0         \n [70] pkgconfig_2.0.3       uwot_0.1.14           deldir_1.0-6         \n [73] utf8_1.2.2            labeling_0.4.2        tidyselect_1.2.0     \n [76] rlang_1.0.6           reshape2_1.4.4        later_1.3.0          \n [79] cellranger_1.1.0      munsell_0.5.0         tools_4.2.2          \n [82] cachem_1.0.6          cli_3.4.1             gsubfn_0.7           \n [85] generics_0.1.2        devtools_2.4.3        ggridges_0.5.4       \n [88] evaluate_0.18         fastmap_1.1.0         goftest_1.2-3        \n [91] yaml_2.3.5            processx_3.7.0        knitr_1.40           \n [94] fs_1.5.2              fitdistrplus_1.1-8    purrr_0.3.4          \n [97] RANN_2.6.1            dendextend_1.16.0     nlme_3.1-160         \n[100] pbapply_1.6-0         future_1.29.0         mime_0.12            \n[103] brio_1.1.3            compiler_4.2.2        rstudioapi_0.13      \n[106] plotly_4.10.0         png_0.1-7             spatstat.utils_3.0-1 \n[109] tibble_3.1.7          stringi_1.7.6         ps_1.7.0             \n[112] desc_1.4.1            rgeos_0.5-9           lattice_0.20-45      \n[115] vctrs_0.5.0           pillar_1.8.1          lifecycle_1.0.3      \n[118] spatstat.geom_3.0-3   lmtest_0.9-40         GlobalOptions_0.1.2  \n[121] RcppAnnoy_0.0.19      cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    gridExtra_2.3        \n[130] IRanges_2.31.2        parallelly_1.32.1     sessioninfo_1.2.2    \n[133] codetools_0.2-18      MASS_7.3-58           assertthat_0.2.1     \n[136] pkgload_1.3.0         proto_1.0.0           rprojroot_2.0.3      \n[139] rjson_0.2.21          withr_2.5.0           SeuratObject_4.1.2   \n[142] sctransform_0.3.5     S4Vectors_0.35.0      mgcv_1.8-41          \n[145] parallel_4.2.2        rpart_4.1.19          grid_4.2.2           \n[148] tidyr_1.2.0           rmarkdown_2.17        Rfast_2.0.6          \n[151] Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html",
    "title": "Cleaning notebook patient 12",
    "section": "",
    "text": "Last compiled"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#import-data",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#import-data",
    "title": "Cleaning notebook patient 12",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient12_Uninvolved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 12\" \n                        & metadata$status %in% c(\"Uninvolved\"#,\n                                                 #\"Involved\",\n                                                 #\"PBMC\"\n                                                 )\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"186 dimension 33694 102271\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5193616 277.4   11217891 599.2  7998122 427.2\nVcells 23858184 182.1   56456612 430.8 46980510 358.5\n\ndim(raw.total)\n\n[1]  33694 102271\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 14420\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  16136 102271\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 16136 59611\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 16136 59611"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#general-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#general-cleaning",
    "title": "Cleaning notebook patient 12",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 50)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 50.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 50]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 7500]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 1500])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 16136  9156\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n186_TAAGTGCAGACGCTTT-1 186_ACTGAACGTATAGGGC-1 186_ATCGAGTGTGTTCTTT-1 \n                    30                     31                     31 \n186_CCACTACCAATGAATG-1 186_CCCTCCTCAGTTCCCT-1 186_CAGCGACGTTTCGCTC-1 \n                    31                     31                     32 \n186_ACCGTAAGTATATCCG-1 186_ATCTACTTCATATCGG-1 186_CAACCTCCATGTTCCC-1 \n                    33                     33                     33 \n186_CATATTCTCGACCAGC-1 \n                    33 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972021_186\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = \"patient.12 ileum\")\n\nSetting new log level to 1\n\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient12_Uninvolved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 7942\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#cotan-specific-data-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#cotan-specific-data-cleaning",
    "title": "Cleaning notebook patient 12",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5290005 282.6   11217891 599.2  9024817 482.0\nVcells 28326309 216.2   67827934 517.5 67827932 517.5\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [6073] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 3372 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#import-data-1",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#import-data-1",
    "title": "Cleaning notebook patient 12",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient12_Involved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 12\" \n                        & metadata$status %in% c(#\"Uninvolved\"#,\n                                                 \"Involved\"#,\n                                                 #\"PBMC\"\n                                                 )\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"187 dimension 33694 59097\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used   (Mb)\nNcells  5350558 285.8   11217891 599.2  11217891  599.2\nVcells 33777716 257.8  102540494 782.4 131940182 1006.7\n\ndim(raw.total)\n\n[1] 33694 59097\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 16648\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1] 13678 59097\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 13678  9272\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 13678  9272"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#general-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#general-cleaning-1",
    "title": "Cleaning notebook patient 12",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 40)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 40.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 40]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 7500]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 13678  4004\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n187_TATTACCTCACTATTC-1 187_ATGCGATTCAAACAAG-1 187_CGGGTCAAGTTGAGAT-1 \n                    30                     31                     31 \n187_CTTAACTAGGCGCTCT-1 187_GCTGGGTCAGGTCCAC-1 187_GGTGTTAGTTCGCGAC-1 \n                    31                     31                     31 \n187_TCACAAGGTAGCGTAG-1 187_AGAGCTTAGAAGATTC-1 187_GCAATCAAGAGCAATT-1 \n                    31                     32                     32 \n187_TGGGAAGAGGTCATCT-1 \n                    32 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972022_187\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = \"patient.12 ileum\")\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient12_Involved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 3915\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#cotan-specific-data-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#cotan-specific-data-cleaning-1",
    "title": "Cleaning notebook patient 12",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used   (Mb)\nNcells  5282070 282.1   11217891 599.2  11217891  599.2\nVcells 30774470 234.8  102540494 782.4 131940182 1006.7\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [3304] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"genes\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 897 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#import-data-2",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#import-data-2",
    "title": "Cleaning notebook patient 12",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient12_PBMC\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 12\" \n                        & metadata$status %in% c(#\"Uninvolved\"#,\n                                                 #\"Involved\",\n                                                 \"PBMC\"\n                                                 )\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"185 dimension 33694 111194\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used   (Mb)\nNcells  5401049 288.5   11217891 599.2  11217891  599.2\nVcells 33708061 257.2  102540494 782.4 131940182 1006.7\n\ndim(raw.total)\n\n[1]  33694 111194\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 15741\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  15152 111194\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 15152 55573\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 15152 55573"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#general-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#general-cleaning-2",
    "title": "Cleaning notebook patient 12",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 50)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 50.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 50]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 7500]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 15152  8185\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n185_GCTGGGTAGAGATGAG-1 185_TCTCATAAGGTAAACT-1 185_CACCTTGCATATACCG-1 \n                    30                     30                     31 \n185_AACCGCGTCCTTGACC-1 185_AGAGTGGAGTCAAGCG-1 185_AGCTCTCCATTGGTAC-1 \n                    32                     32                     32 \n185_CTGAAACGTTGATTGC-1 185_GATGAAAGTCGGCATC-1 185_GTTACAGGTTAGATGA-1 \n                    32                     32                     32 \n185_GAATGAACAAGAAAGG-1 \n                    33 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM4761142_185\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = \"patient.12 ileum\")\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient12_PBMC\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 7794\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient12_NB.html#cotan-specific-data-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient12_NB.html#cotan-specific-data-cleaning-2",
    "title": "Cleaning notebook patient 12",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used   (Mb)\nNcells  5327808 284.6   11217891 599.2  11217891  599.2\nVcells 39295050 299.8  102540494 782.4 131940182 1006.7\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [3492] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 3846 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))\n\n\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    stringr_1.4.0     ggrepel_0.9.2    \n[5] ggplot2_3.4.0     Matrix_1.5-1      data.table_1.14.2\n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       viridis_0.6.2         fansi_1.0.3          \n [16] magrittr_2.0.3        memoise_2.0.1         tensor_1.5           \n [19] cluster_2.1.4         doParallel_1.0.17     ROCR_1.0-11          \n [22] remotes_2.4.2         ComplexHeatmap_2.13.0 globals_0.16.2       \n [25] matrixStats_0.63.0    spatstat.sparse_3.0-0 prettyunits_1.1.1    \n [28] colorspace_2.0-3      xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            viridisLite_0.4.0     xtable_1.8-4         \n [58] clue_0.3-61           reticulate_1.25       spatstat.core_2.4-4  \n [61] stats4_4.2.2          htmlwidgets_1.5.4     httr_1.4.4           \n [64] RColorBrewer_1.1-3    ellipsis_0.3.2        Seurat_4.2.0         \n [67] factoextra_1.0.7      ica_1.0-2             farver_2.1.0         \n [70] pkgconfig_2.0.3       uwot_0.1.14           deldir_1.0-6         \n [73] utf8_1.2.2            labeling_0.4.2        tidyselect_1.2.0     \n [76] rlang_1.0.6           reshape2_1.4.4        later_1.3.0          \n [79] cellranger_1.1.0      munsell_0.5.0         tools_4.2.2          \n [82] cachem_1.0.6          cli_3.4.1             gsubfn_0.7           \n [85] generics_0.1.2        devtools_2.4.3        ggridges_0.5.4       \n [88] evaluate_0.18         fastmap_1.1.0         goftest_1.2-3        \n [91] yaml_2.3.5            processx_3.7.0        knitr_1.40           \n [94] fs_1.5.2              fitdistrplus_1.1-8    purrr_0.3.4          \n [97] RANN_2.6.1            dendextend_1.16.0     nlme_3.1-160         \n[100] pbapply_1.6-0         future_1.29.0         mime_0.12            \n[103] brio_1.1.3            compiler_4.2.2        rstudioapi_0.13      \n[106] plotly_4.10.0         png_0.1-7             spatstat.utils_3.0-1 \n[109] tibble_3.1.7          stringi_1.7.6         ps_1.7.0             \n[112] desc_1.4.1            rgeos_0.5-9           lattice_0.20-45      \n[115] vctrs_0.5.0           pillar_1.8.1          lifecycle_1.0.3      \n[118] spatstat.geom_3.0-3   lmtest_0.9-40         GlobalOptions_0.1.2  \n[121] RcppAnnoy_0.0.19      cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    gridExtra_2.3        \n[130] IRanges_2.31.2        parallelly_1.32.1     sessioninfo_1.2.2    \n[133] codetools_0.2-18      MASS_7.3-58           assertthat_0.2.1     \n[136] pkgload_1.3.0         proto_1.0.0           rprojroot_2.0.3      \n[139] rjson_0.2.21          withr_2.5.0           SeuratObject_4.1.2   \n[142] sctransform_0.3.5     S4Vectors_0.35.0      mgcv_1.8-41          \n[145] parallel_4.2.2        rpart_4.1.19          grid_4.2.2           \n[148] tidyr_1.2.0           rmarkdown_2.17        Rfast_2.0.6          \n[151] Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html",
    "title": "Cleaning notebook patient 14",
    "section": "",
    "text": "Last compiled"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#import-datmeta",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#import-datmeta",
    "title": "Cleaning notebook patient 14",
    "section": "Import datmeta",
    "text": "Import datmeta\n\npatient <- \"patient14_Uninvolved\"\nstatus <- \"Uninvolved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 14\" \n                        & metadata$status == status\n, ,drop = FALSE])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"192 dimension 33694 128835\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger  (Mb) max used  (Mb)\nNcells  5220161 278.8   11310040 604.1  7998077 427.2\nVcells 29723412 226.8   73702307 562.4 69336691 529.0\n\ndim(raw.total)\n\n[1]  33694 128835\n\n\nDefine output directory:\n\nroot <- \"../../Crohn_disease/\"\nout_dir <- paste0(root,\"data/02_cleaned_data/\")\nout_dir\n\n[1] \"../../Crohn_disease/data/02_cleaned_data/\"\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 12800\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  17875 128835\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 17875 76303\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 17875 76303"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#general-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#general-cleaning",
    "title": "Cleaning notebook patient 14",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 40)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 40.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 40]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 15000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nDrop cells with less than 30 genes detected\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 3000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 17875 13562\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2500])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n192_CATCAAGTCAGCTCTC-1 192_TGAGCATAGATACACA-1 192_AGTGTCAAGCTGCCCA-1 \n                    30                     30                     31 \n192_CGTAGGCGTCAAACTC-1 192_CGTCCATAGAGTCTGG-1 192_GACTACACAACACCCG-1 \n                    31                     31                     31 \n192_GCTGGGTCAAGTAATG-1 192_GGAGCAATCTCAAACG-1 192_TAAACCGGTCAGTGGA-1 \n                    31                     31                     31 \n192_TGTGGTAAGTGCCATT-1 \n                    31 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972025_192\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.14 ileum \",status))\n\nSetting new log level to 1\n\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient14_Uninvolved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 9990\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#cotan-specific-data-cleaning",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#cotan-specific-data-cleaning",
    "title": "Cleaning notebook patient 14",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\nFirst, we create a directory to store all information regarding the data cleaning.\n\nif(!file.exists(out_dir)){\n  dir.create(file.path(out_dir))\n}\n\nif(!file.exists(paste(out_dir,\"cleaning\", sep = \"\"))){   \n  dir.create(file.path(out_dir, \"cleaning\"))\n}\n\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger  (Mb)  max used  (Mb)\nNcells  5308515 283.6   11310040 604.1  10585665 565.4\nVcells 46287056 353.2  106307321 811.1 106185493 810.2\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [6231] genes and [0] cells\n\nplots <- cleanPlots(obj)\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,2000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.5, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 7990 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#import-data",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#import-data",
    "title": "Cleaning notebook patient 14",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient14_Involved\"\nstatus <- \"Involved\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 14\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"193 dimension 33694 131413\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5424929 289.8   11310040  604.1  11310040  604.1\nVcells 55728911 425.2  164436878 1254.6 212600992 1622.1\n\ndim(raw.total)\n\n[1]  33694 131413\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 13231\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  17389 131413\n\n\n\nraw.total <- raw.total[,!colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 17389 83051\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 17389 83051"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#general-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#general-cleaning-1",
    "title": "Cleaning notebook patient 14",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 30)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 30.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 30]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 15000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2500])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 17389 16089\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2000])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n193_AACACGTCACAGGAGT-1 193_AACTCAGTCACATACG-1 193_AACTCCCCATGCCCGA-1 \n                    30                     30                     30 \n193_AAGCCGCCATTCTTAC-1 193_ACACCAACAGGTCTCG-1 193_ACAGCTAGTAAATACG-1 \n                    30                     30                     30 \n193_ACATACGGTGCACTTA-1 193_ACATGGTCATCACAAC-1 193_ACCAGTACACCAGCAC-1 \n                    30                     30                     30 \n193_ACCAGTACATATGCTG-1 \n                    30 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM3972026_193\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.14 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient14_Involved\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 13846\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#cotan-specific-data-cleaning-1",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#cotan-specific-data-cleaning-1",
    "title": "Cleaning notebook patient 14",
    "section": "COTAN specific data cleaning",
    "text": "COTAN specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5361564 286.4   11310040  604.1  11310040  604.1\nVcells 66548812 507.8  164437367 1254.6 212600992 1622.1\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [6720] genes and [0] cells\n\nplots <- cleanPlots(obj)\n\nWarning in asMethod(object): sparse->dense coercion: allocating vector of size\n1.1 GiB\n\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low.\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,8000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 5846 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#import-data-1",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#import-data-1",
    "title": "Cleaning notebook patient 14",
    "section": "Import data",
    "text": "Import data\n\npatient <- \"patient14_PBMC\"\nstatus <- \"PBMC\"\nmetadata <- readxl::read_excel(\"../data/tables-mmc2.xlsx\",sheet = 1)\nmetadata <- as.data.frame(metadata[metadata$Patient.ID == \"pat. 14\" \n                        & metadata$status %in% status\n,])\nmetadata <- metadata[!is.na(metadata$Sample_ID),]\n\n\nraw.total <- NA\nfor (sample in metadata$Sample_ID) {\n  raw <- Seurat::Read10X(paste0(\"../data/01_raw_data/\",sample,\"/\"),gene.column = 2)\n  colnames(raw) <- paste0(sample,\"_\",colnames(raw))\n  raw <- raw[,!(Matrix::colSums(raw) <= 1)]\n  print(paste0(sample,\" dimension \",dim(raw)[1],\" \",dim(raw)[2]))\n  if(is.null(dim(raw.total))){\n    raw.total <- raw\n  }else{\n    if ( identical(rownames(raw),rownames(raw.total) )) {\n      raw.total <- cbind(raw.total,raw)  \n    }else{\n      print(\"Problem!\")\n      break\n    }\n    \n  }\n}\n\n[1] \"191 dimension 33694 168519\"\n\nrm(raw)\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5468521 292.1   11310040  604.1  11310040  604.1\nVcells 70635856 539.0  230427171 1758.1 373594382 2850.3\n\ndim(raw.total)\n\n[1]  33694 168519\n\n\nWe check also the genes\n\nsum(Matrix::rowSums(raw.total) <= 1)\n\n[1] 14112\n\n\nAnd drop the empty rows.\n\nraw.total <- raw.total[!(Matrix::rowSums(raw.total) <= 5),]\ndim(raw.total)\n\n[1]  16784 168519\n\n\n\nraw.total <- raw.total[,!Matrix::colSums(raw.total) <= 5]\ndim(raw.total)\n\n[1] 16784 82129\n\n\n\nobj <- COTAN(raw = raw.total)\n\n\ndim(getRawData(obj))\n\n[1] 16784 82129"
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#general-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#general-cleaning-2",
    "title": "Cleaning notebook patient 14",
    "section": "General cleaning",
    "text": "General cleaning\nWe want to remove cell doublets or multiplets and low-quality or dying cells (with too high mtRNA percentage).\n\nBy library sizes\nFirst, we check the library size (UMI number) with an empirical cumulative distribution function.\n\nECDPlot(obj, yCut = 50)\n\n\n\n\nSo to start we drop all cells with library sizes lower than 50.\nThe next plot shows the library size of each cell in a violin and box plot.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) < 50]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nWe can subset and drop the unwanted cell by library size.\n\nobj <- dropGenesCells(obj,cells = names(getCellsSize(obj)[getCellsSize(obj) > 10000]))\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nDetected genes\nThe next plot shows the number of genes detected in each cell in a violin and box plot.\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) < 30])\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nAnd we drop again possible doublets\n\nto.drop <- names(sort(colSums(getRawData(obj) > 0),decreasing = F)[sort(colSums(getRawData(obj) > 0),decreasing = F) > 2500])\n\nobj <- dropGenesCells(obj,cells = to.drop)\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCheck again the library size\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\ndim(getRawData(obj))\n\n[1] 16784 21108\n\n\n\n\nBy mitochondrial gene percentage\nWe will next have a look at the percentage of reads coming from mitochondrial genes. This can help to drop dying cells: these cells will have a percentage of mitochondrial reads particularly high.\n\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\n\nobj <- dropGenesCells(obj,cells = rownames(df$sizes[df$sizes$mit.percentage > 15,]))\ndf <- mitochondrialPercentagePlot(obj,splitPattern = \"_\",numCols = 1,genePrefix = \"^MT-\")\n\ndf$plot\n\n\n\n\nWe check again the library size plot\n\nlibrarySizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\n\ngenesSizePlot(obj,splitPattern = \"_\",numCols = 1)\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\nGene and library size scatter plot\n\nscatterPlot(obj, splitPattern = \"[_]\", numCols = 1)\n\n\n\n\nMin gene number\n\nsort(colSums(getRawData(obj) > 0),decreasing = F)[1:10]\n\n191_CCTAGCTAGGGTTTCT-1 191_GTTCATTAGGCCATAG-1 191_TATTACCCATTAGCCA-1 \n                    31                     31                     31 \n191_CAGCCGAGTAACGCGA-1 191_CAGCGACAGCTATGCT-1 191_TAAACCGGTACAGCAG-1 \n                    32                     32                     32 \n191_TCAGCTCTCCATTCTA-1 191_TTGGCAATCTGATACG-1 191_ACGTCAAGTAGGCATG-1 \n                    32                     32                     33 \n191_ACTGAGTCAGACGCAA-1 \n                    33 \n\n\n\nhist(sort(colSums(getRawData(obj) > 0),decreasing = F),breaks = 100)\n\n\n\n\n\nobj <- initializeMetaDataset(obj,\n                             GEO=\"GSM4761143_191\",\n                             sequencingMethod = \"10X\",\n                             sampleCondition = paste0(\"patient.14 ileum \",status))\n\n\nn_it = 1\nprint(paste(\"Condition \", patient ,sep = \"\"))\n\n[1] \"Condition patient14_PBMC\"\n\n#--------------------------------------\nprint(paste(\"n cells\", getNumCells(obj), sep = \" \"))\n\n[1] \"n cells 20671\""
  },
  {
    "objectID": "Crohn_disease/results/01_cleaning_patient14_NB.html#cotan-specific-data-cleaning-2",
    "href": "Crohn_disease/results/01_cleaning_patient14_NB.html#cotan-specific-data-cleaning-2",
    "title": "Cleaning notebook patient 14",
    "section": "COTAN-specific data cleaning",
    "text": "COTAN-specific data cleaning\n\nPCA cell plot\n\ngc()\n\n           used  (Mb) gc trigger   (Mb)  max used   (Mb)\nNcells  5365831 286.6   11310040  604.1  11310040  604.1\nVcells 79501018 606.6  230427171 1758.1 373594382 2850.3\n\nobj <- clean(obj)\n\nGenes/cells selection done: dropped [5586] genes and [0] cells\n\nplots <- cleanPlots(obj)\n\nWarning in asMethod(object): sparse->dense coercion: allocating vector of size\n1.7 GiB\n\nplots$pcaCells\n\n\n\n\n\npcaCells <- plots$pcaCells\npcaCells$data$code <- str_split(rownames(plots$pcaCells$data),pattern = \"_\",simplify = T)[,1]\n\nggplot(pcaCells$data, aes(x=PC1, y=PC2,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nggplot(pcaCells$data, aes(x=PC1, y=PC3,colour =code)) +\n                  geom_point(alpha = 0.5, size=0.5)\n\n\n\n\n\nplots$genes\n\n\n\n\n\n\nUDE plots\nTo color the PCA based on cells’ RNA extraction efficiency\n\nplots[[\"UDE\"]]\n\n\n\n\nUDE (color) should not correlate with principal components! This is very important. The next part is used to remove the cells with efficiency too low. Here the problem is that there seem to be two different cell populations: one with a low amount of RNA and low number of genes and another with a high amount.(Maybe neutrophils?)\n\nplots[[\"nu\"]]\n\n\n\n\nWe can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells low UDE cells.\n\nyset = 0.05#threshold to remove low UDE cells\nplots[[\"nu\"]] + \n  ylim(0,1) + xlim(0,3000) +\n    geom_hline(yintercept=yset, linetype=\"dashed\", color = \"darkred\") +\n    annotate(geom=\"text\", x=200, y=0.05, \n             label=paste(\"to remove cells with nu < \",yset,sep = \" \"), \n             color=\"darkred\", size=4.5)\n\nWarning: Removed 17671 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nsaveRDS(obj,paste0(out_dir,patient,\"_obj_cotan.RDS\"))\n\n\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    stringr_1.4.0     ggrepel_0.9.2    \n[5] ggplot2_3.4.0     Matrix_1.5-1      data.table_1.14.2\n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       viridis_0.6.2         fansi_1.0.3          \n [16] magrittr_2.0.3        memoise_2.0.1         tensor_1.5           \n [19] cluster_2.1.4         doParallel_1.0.17     ROCR_1.0-11          \n [22] remotes_2.4.2         ComplexHeatmap_2.13.0 globals_0.16.2       \n [25] matrixStats_0.63.0    spatstat.sparse_3.0-0 prettyunits_1.1.1    \n [28] colorspace_2.0-3      xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            viridisLite_0.4.0     xtable_1.8-4         \n [58] clue_0.3-61           reticulate_1.25       spatstat.core_2.4-4  \n [61] stats4_4.2.2          htmlwidgets_1.5.4     httr_1.4.4           \n [64] RColorBrewer_1.1-3    ellipsis_0.3.2        Seurat_4.2.0         \n [67] factoextra_1.0.7      ica_1.0-2             farver_2.1.0         \n [70] pkgconfig_2.0.3       uwot_0.1.14           deldir_1.0-6         \n [73] utf8_1.2.2            labeling_0.4.2        tidyselect_1.2.0     \n [76] rlang_1.0.6           reshape2_1.4.4        later_1.3.0          \n [79] cellranger_1.1.0      munsell_0.5.0         tools_4.2.2          \n [82] cachem_1.0.6          cli_3.4.1             gsubfn_0.7           \n [85] generics_0.1.2        devtools_2.4.3        ggridges_0.5.4       \n [88] evaluate_0.18         fastmap_1.1.0         goftest_1.2-3        \n [91] yaml_2.3.5            processx_3.7.0        knitr_1.40           \n [94] fs_1.5.2              fitdistrplus_1.1-8    purrr_0.3.4          \n [97] RANN_2.6.1            dendextend_1.16.0     nlme_3.1-160         \n[100] pbapply_1.6-0         future_1.29.0         mime_0.12            \n[103] brio_1.1.3            compiler_4.2.2        rstudioapi_0.13      \n[106] plotly_4.10.0         png_0.1-7             spatstat.utils_3.0-1 \n[109] tibble_3.1.7          stringi_1.7.6         ps_1.7.0             \n[112] desc_1.4.1            rgeos_0.5-9           lattice_0.20-45      \n[115] vctrs_0.5.0           pillar_1.8.1          lifecycle_1.0.3      \n[118] spatstat.geom_3.0-3   lmtest_0.9-40         GlobalOptions_0.1.2  \n[121] RcppAnnoy_0.0.19      cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    gridExtra_2.3        \n[130] IRanges_2.31.2        parallelly_1.32.1     sessioninfo_1.2.2    \n[133] codetools_0.2-18      MASS_7.3-58           assertthat_0.2.1     \n[136] pkgload_1.3.0         proto_1.0.0           rprojroot_2.0.3      \n[139] rjson_0.2.21          withr_2.5.0           SeuratObject_4.1.2   \n[142] sctransform_0.3.5     S4Vectors_0.35.0      mgcv_1.8-41          \n[145] parallel_4.2.2        rpart_4.1.19          grid_4.2.2           \n[148] tidyr_1.2.0           rmarkdown_2.17        Rfast_2.0.6          \n[151] Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/04_Data_exploration_clusters_id_patient7_NB.html",
    "href": "Crohn_disease/results/04_Data_exploration_clusters_id_patient7_NB.html",
    "title": "Data exploration patient 7",
    "section": "",
    "text": "today <- Sys.Date()\nformat(today, format = \"%A %d %B %Y\")\n\n[1] \"Wednesday 21 December 2022\"\n\n\n\nImport markers\n\nmarkers <- readxl::read_excel(\"../../Marker_genes.xlsx\",sheet = 1)\n\nNew names:\n• `` -> `...1`\n\nmarkers <- as.list(markers)\nmarkers <- markers[2:length(markers)]\nfor (nv in names(markers)) {\n  markers[[nv]] <- unique(markers[[nv]][!is.na(markers[[nv]])])\n}\n\n\n\nUninvolved ileum samples\n\nout_dir <- \"../../Crohn_disease/data/04_cluster_identification/\"\nin_dir <- \"../../Crohn_disease/data/02_cleaned_data/\"\nsample.id = \"patient7_Uninvolved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 261   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how much a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x-axis, there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\n\nSetting new log level to 1\n\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 30 detected over 42 genes\"\n[1] \"In Enterocytes there are 3 detected over 4 genes\"\n[1] \"In Goblet cells there are 1 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 3 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 2 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 6 detected over 6 genes\"\n[1] \"In Mast cells there are 5 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 6 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 4 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 4 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 3 detected over 4 genes\"\n[1] \"In Neutrophils there are 4 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score isubpopulationesent in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 261 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detected in thex-axis,e.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         30       42\nEnterocytes                               3        4\nGoblet cells                              1        6\nEnteroendocrine cells                     0        4\nPaneth cells                              3        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                2        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     6       11\nILC3                                      6        6\nMast cells                                5        6\nEndotelial Cells                          6        7\n??                                        0        2\nFibroblasts                               4        6\nSmooth muscle cells                       4        5\nEnteric glia cells                        3        4\nNeutrophils                               4        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     261      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nInvolved ileum samples\n\nsample.id = \"patient7_Involved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 296   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is different,tially expressed in the dataset. Genes expressed only in a sub-population of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 39 detected over 42 genes\"\n[1] \"In Enterocytes there are 1 detected over 4 genes\"\n[1] \"In Goblet cells there are 4 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 2 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 5 detected over 5 genes\"\n[1] \"In Stem cells there are 3 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 8 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 7 detected over 11 genes\"\n[1] \"In ILC3 there are 6 detected over 6 genes\"\n[1] \"In Mast cells there are 4 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 6 detected over 7 genes\"\n[1] \"In ?? there are 1 detected over 2 genes\"\n[1] \"In Fibroblasts there are 5 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 4 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 6 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score if a gene is present in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 296 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detecx-axis the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         39       42\nEnterocytes                               1        4\nGoblet cells                              4        6\nEnteroendocrine cells                     0        4\nPaneth cells                              2        3\nTuft cells                                0        3\nTA cells                                  5        5\nStem cells                                3        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           8        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     7       11\nILC3                                      6        6\nMast cells                                4        6\nEndotelial Cells                          6        7\n??                                        1        2\nFibroblasts                               5        6\nSmooth muscle cells                       4        5\nEnteric glia cells                        2        4\nNeutrophils                               6        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     296      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nPBMC samples\n\nsample.id = \"patient7_PBMC\"\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 242   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 6 detected over 42 genes\"\n[1] \"In Enterocytes there are 1 detected over 4 genes\"\n[1] \"In Goblet cells there are 0 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 3 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 3 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 2 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 8 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 8 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 1 detected over 6 genes\"\n[1] \"In Mast cells there are 1 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 2 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 2 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 7 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score is a gene is present in more marker list)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 242 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how may are detected in the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          6       42\nEnterocytes                               1        4\nGoblet cells                              0        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  3        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           3        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              2        4\nDendridic Cells                           8        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           8        8\nILC1s                                    10       11\nILC2s                                     6       11\nILC3                                      1        6\nMast cells                                1        6\nEndotelial Cells                          2        7\n??                                        0        2\nFibroblasts                               2        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               7        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     242      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was longer than the number of\nclusters - first k elements are used\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\nSession info\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    dendextend_1.16.0 stringr_1.4.0    \n[5] ggplot2_3.4.0     viridis_0.6.2     viridisLite_0.4.0 gridExtra_2.3    \n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       fansi_1.0.3           magrittr_2.0.3       \n [16] memoise_2.0.1         tensor_1.5            cluster_2.1.4        \n [19] doParallel_1.0.17     ROCR_1.0-11           remotes_2.4.2        \n [22] ComplexHeatmap_2.13.0 globals_0.16.2        matrixStats_0.63.0   \n [25] spatstat.sparse_3.0-0 prettyunits_1.1.1     colorspace_2.0-3     \n [28] ggrepel_0.9.2         xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            xtable_1.8-4          clue_0.3-61          \n [58] spatstat.core_2.4-4   reticulate_1.25       stats4_4.2.2         \n [61] htmlwidgets_1.5.4     httr_1.4.4            RColorBrewer_1.1-3   \n [64] ellipsis_0.3.2        Seurat_4.2.0          factoextra_1.0.7     \n [67] ica_1.0-2             farver_2.1.0          pkgconfig_2.0.3      \n [70] uwot_0.1.14           deldir_1.0-6          utf8_1.2.2           \n [73] labeling_0.4.2        tidyselect_1.2.0      rlang_1.0.6          \n [76] reshape2_1.4.4        later_1.3.0           cellranger_1.1.0     \n [79] munsell_0.5.0         tools_4.2.2           cachem_1.0.6         \n [82] cli_3.4.1             gsubfn_0.7            generics_0.1.2       \n [85] devtools_2.4.3        ggridges_0.5.4        evaluate_0.18        \n [88] fastmap_1.1.0         goftest_1.2-3         yaml_2.3.5           \n [91] processx_3.7.0        knitr_1.40            fs_1.5.2             \n [94] fitdistrplus_1.1-8    purrr_0.3.4           RANN_2.6.1           \n [97] nlme_3.1-160          pbapply_1.6-0         future_1.29.0        \n[100] mime_0.12             brio_1.1.3            compiler_4.2.2       \n[103] rstudioapi_0.13       plotly_4.10.0         png_0.1-7            \n[106] spatstat.utils_3.0-1  tibble_3.1.7          stringi_1.7.6        \n[109] ps_1.7.0              desc_1.4.1            rgeos_0.5-9          \n[112] lattice_0.20-45       Matrix_1.5-1          vctrs_0.5.0          \n[115] pillar_1.8.1          lifecycle_1.0.3       spatstat.geom_3.0-3  \n[118] lmtest_0.9-40         GlobalOptions_0.1.2   RcppAnnoy_0.0.19     \n[121] data.table_1.14.2     cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    IRanges_2.31.2       \n[130] parallelly_1.32.1     sessioninfo_1.2.2     codetools_0.2-18     \n[133] MASS_7.3-58           assertthat_0.2.1      pkgload_1.3.0        \n[136] proto_1.0.0           rprojroot_2.0.3       rjson_0.2.21         \n[139] withr_2.5.0           SeuratObject_4.1.2    sctransform_0.3.5    \n[142] S4Vectors_0.35.0      mgcv_1.8-41           parallel_4.2.2       \n[145] rpart_4.1.19          tidyr_1.2.0           rmarkdown_2.17       \n[148] Rfast_2.0.6           Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/04_Data_exploration_clusters_id_patient11_NB.html",
    "href": "Crohn_disease/results/04_Data_exploration_clusters_id_patient11_NB.html",
    "title": "Data exploration patient 11",
    "section": "",
    "text": "today <- Sys.Date()\nformat(today, format = \"%A %d %B %Y\")\n\n[1] \"Thursday 22 December 2022\"\n\n\n\nImport markers\n\nmarkers <- readxl::read_excel(\"../../Marker_genes.xlsx\",sheet = 1)\n\nNew names:\n• `` -> `...1`\n\nmarkers <- as.list(markers)\nmarkers <- markers[2:length(markers)]\nfor (nv in names(markers)) {\n  markers[[nv]] <- unique(markers[[nv]][!is.na(markers[[nv]])])\n}\n\n\n\nUninvolved ileum samples\n\nout_dir <- \"../../Crohn_disease/data/04_cluster_identification/\"\nin_dir <- \"../../Crohn_disease/data/02_cleaned_data/\"\nsample.id = \"patient11_Uninvolved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 289   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how much a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x-axis, there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\n\nSetting new log level to 1\n\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 40 detected over 42 genes\"\n[1] \"In Enterocytes there are 1 detected over 4 genes\"\n[1] \"In Goblet cells there are 5 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 3 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 5 detected over 5 genes\"\n[1] \"In Stem cells there are 3 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 7 detected over 11 genes\"\n[1] \"In ILC3 there are 6 detected over 6 genes\"\n[1] \"In Mast cells there are 6 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 4 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 5 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 5 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 6 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score isubpopulationesent in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 289 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detected in thex-axis,e.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         40       42\nEnterocytes                               1        4\nGoblet cells                              5        6\nEnteroendocrine cells                     0        4\nPaneth cells                              3        3\nTuft cells                                0        3\nTA cells                                  5        5\nStem cells                                3        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     7       11\nILC3                                      6        6\nMast cells                                6        6\nEndotelial Cells                          4        7\n??                                        0        2\nFibroblasts                               5        6\nSmooth muscle cells                       5        5\nEnteric glia cells                        2        4\nNeutrophils                               6        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     289      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nInvolved ileum samples\n\nsample.id = \"patient11_Involved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 257   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is different,tially expressed in the dataset. Genes expressed only in a sub-population of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 20 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 1 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 5 detected over 5 genes\"\n[1] \"In Stem cells there are 2 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 4 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 6 detected over 8 genes\"\n[1] \"In ILC1s there are 9 detected over 11 genes\"\n[1] \"In ILC2s there are 7 detected over 11 genes\"\n[1] \"In ILC3 there are 5 detected over 6 genes\"\n[1] \"In Mast cells there are 3 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 5 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 3 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 2 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 4 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 4 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score if a gene is present in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 257 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detecx-axis the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         20       42\nEnterocytes                               0        4\nGoblet cells                              1        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  5        5\nStem cells                                2        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               4        5\nILCs - Cytotoxic natural killer           6        8\nILC1s                                     9       11\nILC2s                                     7       11\nILC3                                      5        6\nMast cells                                3        6\nEndotelial Cells                          5        7\n??                                        0        2\nFibroblasts                               3        6\nSmooth muscle cells                       2        5\nEnteric glia cells                        2        4\nNeutrophils                               4        8\nEosinophil                                0        2\nBasophils                                 4        6\nISG                                     257      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nPBMC samples\n\nsample.id = \"patient11_PBMC\"\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 253   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 5 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 0 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 2 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 2 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 8 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 3 detected over 6 genes\"\n[1] \"In Mast cells there are 0 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 2 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 2 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 4 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 5 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 4 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score is a gene is present in more marker list)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 253 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how may are detected in the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          5       42\nEnterocytes                               0        4\nGoblet cells                              0        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                2        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              2        4\nDendridic Cells                           7        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           8        8\nILC1s                                    10       11\nILC2s                                     6       11\nILC3                                      3        6\nMast cells                                0        6\nEndotelial Cells                          2        7\n??                                        0        2\nFibroblasts                               2        6\nSmooth muscle cells                       4        5\nEnteric glia cells                        2        4\nNeutrophils                               5        8\nEosinophil                                0        2\nBasophils                                 4        6\nISG                                     253      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\nSession info\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    dendextend_1.16.0 stringr_1.4.0    \n[5] ggplot2_3.4.0     viridis_0.6.2     viridisLite_0.4.0 gridExtra_2.3    \n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       fansi_1.0.3           magrittr_2.0.3       \n [16] memoise_2.0.1         tensor_1.5            cluster_2.1.4        \n [19] doParallel_1.0.17     ROCR_1.0-11           remotes_2.4.2        \n [22] ComplexHeatmap_2.13.0 globals_0.16.2        matrixStats_0.63.0   \n [25] spatstat.sparse_3.0-0 prettyunits_1.1.1     colorspace_2.0-3     \n [28] ggrepel_0.9.2         xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            xtable_1.8-4          clue_0.3-61          \n [58] spatstat.core_2.4-4   reticulate_1.25       stats4_4.2.2         \n [61] htmlwidgets_1.5.4     httr_1.4.4            RColorBrewer_1.1-3   \n [64] ellipsis_0.3.2        Seurat_4.2.0          factoextra_1.0.7     \n [67] ica_1.0-2             farver_2.1.0          pkgconfig_2.0.3      \n [70] uwot_0.1.14           deldir_1.0-6          utf8_1.2.2           \n [73] labeling_0.4.2        tidyselect_1.2.0      rlang_1.0.6          \n [76] reshape2_1.4.4        later_1.3.0           cellranger_1.1.0     \n [79] munsell_0.5.0         tools_4.2.2           cachem_1.0.6         \n [82] cli_3.4.1             gsubfn_0.7            generics_0.1.2       \n [85] devtools_2.4.3        ggridges_0.5.4        evaluate_0.18        \n [88] fastmap_1.1.0         goftest_1.2-3         yaml_2.3.5           \n [91] processx_3.7.0        knitr_1.40            fs_1.5.2             \n [94] fitdistrplus_1.1-8    purrr_0.3.4           RANN_2.6.1           \n [97] nlme_3.1-160          pbapply_1.6-0         future_1.29.0        \n[100] mime_0.12             brio_1.1.3            compiler_4.2.2       \n[103] rstudioapi_0.13       plotly_4.10.0         png_0.1-7            \n[106] spatstat.utils_3.0-1  tibble_3.1.7          stringi_1.7.6        \n[109] ps_1.7.0              desc_1.4.1            rgeos_0.5-9          \n[112] lattice_0.20-45       Matrix_1.5-1          vctrs_0.5.0          \n[115] pillar_1.8.1          lifecycle_1.0.3       spatstat.geom_3.0-3  \n[118] lmtest_0.9-40         GlobalOptions_0.1.2   RcppAnnoy_0.0.19     \n[121] data.table_1.14.2     cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    IRanges_2.31.2       \n[130] parallelly_1.32.1     sessioninfo_1.2.2     codetools_0.2-18     \n[133] MASS_7.3-58           assertthat_0.2.1      pkgload_1.3.0        \n[136] proto_1.0.0           rprojroot_2.0.3       rjson_0.2.21         \n[139] withr_2.5.0           SeuratObject_4.1.2    sctransform_0.3.5    \n[142] S4Vectors_0.35.0      mgcv_1.8-41           parallel_4.2.2       \n[145] rpart_4.1.19          tidyr_1.2.0           rmarkdown_2.17       \n[148] Rfast_2.0.6           Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/04_Data_exploration_clusters_id_patient10_NB.html",
    "href": "Crohn_disease/results/04_Data_exploration_clusters_id_patient10_NB.html",
    "title": "Data exploration patient 10",
    "section": "",
    "text": "today <- Sys.Date()\nformat(today, format = \"%A %d %B %Y\")\n\n[1] \"Wednesday 21 December 2022\"\n\n\n\nImport markers\n\nmarkers <- readxl::read_excel(\"../../Marker_genes.xlsx\",sheet = 1)\n\nNew names:\n• `` -> `...1`\n\nmarkers <- as.list(markers)\nmarkers <- markers[2:length(markers)]\nfor (nv in names(markers)) {\n  markers[[nv]] <- unique(markers[[nv]][!is.na(markers[[nv]])])\n}\n\n\n\nUninvolved ileum samples\n\nout_dir <- \"../../Crohn_disease/data/04_cluster_identification/\"\nin_dir <- \"../../Crohn_disease/data/02_cleaned_data/\"\nsample.id = \"patient10_Uninvolved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 260   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how much a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x-axis, there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\n\nSetting new log level to 1\n\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 40 detected over 42 genes\"\n[1] \"In Enterocytes there are 4 detected over 4 genes\"\n[1] \"In Goblet cells there are 4 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 3 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 4 detected over 5 genes\"\n[1] \"In Stem cells there are 2 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 4 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 7 detected over 11 genes\"\n[1] \"In ILC3 there are 6 detected over 6 genes\"\n[1] \"In Mast cells there are 5 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 6 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 3 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 4 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 3 detected over 4 genes\"\n[1] \"In Neutrophils there are 3 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score isubpopulationesent in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 260 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detected in thex-axis,e.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         40       42\nEnterocytes                               4        4\nGoblet cells                              4        6\nEnteroendocrine cells                     0        4\nPaneth cells                              3        3\nTuft cells                                0        3\nTA cells                                  4        5\nStem cells                                2        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               4        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     7       11\nILC3                                      6        6\nMast cells                                5        6\nEndotelial Cells                          6        7\n??                                        0        2\nFibroblasts                               3        6\nSmooth muscle cells                       4        5\nEnteric glia cells                        3        4\nNeutrophils                               3        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     260      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nInvolved ileum samples\n\nsample.id = \"patient10_Involved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 270   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is different,tially expressed in the dataset. Genes expressed only in a sub-population of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 37 detected over 42 genes\"\n[1] \"In Enterocytes there are 4 detected over 4 genes\"\n[1] \"In Goblet cells there are 5 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 2 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 5 detected over 5 genes\"\n[1] \"In Stem cells there are 2 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 4 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 7 detected over 11 genes\"\n[1] \"In ILC3 there are 6 detected over 6 genes\"\n[1] \"In Mast cells there are 4 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 5 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 3 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 4 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score if a gene is present in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 270 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detecx-axis the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         37       42\nEnterocytes                               4        4\nGoblet cells                              5        6\nEnteroendocrine cells                     0        4\nPaneth cells                              2        3\nTuft cells                                0        3\nTA cells                                  5        5\nStem cells                                2        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               4        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     7       11\nILC3                                      6        6\nMast cells                                4        6\nEndotelial Cells                          5        7\n??                                        0        2\nFibroblasts                               3        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               4        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     270      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nPBMC samples\n\nsample.id = \"patient10_PBMC\"\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 251   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 7 detected over 42 genes\"\n[1] \"In Enterocytes there are 1 detected over 4 genes\"\n[1] \"In Goblet cells there are 0 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 3 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 2 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 8 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 8 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 5 detected over 11 genes\"\n[1] \"In ILC3 there are 3 detected over 6 genes\"\n[1] \"In Mast cells there are 1 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 2 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 1 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 7 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score is a gene is present in more marker list)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 251 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how may are detected in the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          7       42\nEnterocytes                               1        4\nGoblet cells                              0        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           3        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              2        4\nDendridic Cells                           8        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           8        8\nILC1s                                    10       11\nILC2s                                     5       11\nILC3                                      3        6\nMast cells                                1        6\nEndotelial Cells                          2        7\n??                                        0        2\nFibroblasts                               1        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               7        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     251      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\nSession info\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    dendextend_1.16.0 stringr_1.4.0    \n[5] ggplot2_3.4.0     viridis_0.6.2     viridisLite_0.4.0 gridExtra_2.3    \n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       fansi_1.0.3           magrittr_2.0.3       \n [16] memoise_2.0.1         tensor_1.5            cluster_2.1.4        \n [19] doParallel_1.0.17     ROCR_1.0-11           remotes_2.4.2        \n [22] ComplexHeatmap_2.13.0 globals_0.16.2        matrixStats_0.63.0   \n [25] spatstat.sparse_3.0-0 prettyunits_1.1.1     colorspace_2.0-3     \n [28] ggrepel_0.9.2         xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            xtable_1.8-4          clue_0.3-61          \n [58] spatstat.core_2.4-4   reticulate_1.25       stats4_4.2.2         \n [61] htmlwidgets_1.5.4     httr_1.4.4            RColorBrewer_1.1-3   \n [64] ellipsis_0.3.2        Seurat_4.2.0          factoextra_1.0.7     \n [67] ica_1.0-2             farver_2.1.0          pkgconfig_2.0.3      \n [70] uwot_0.1.14           deldir_1.0-6          utf8_1.2.2           \n [73] labeling_0.4.2        tidyselect_1.2.0      rlang_1.0.6          \n [76] reshape2_1.4.4        later_1.3.0           cellranger_1.1.0     \n [79] munsell_0.5.0         tools_4.2.2           cachem_1.0.6         \n [82] cli_3.4.1             gsubfn_0.7            generics_0.1.2       \n [85] devtools_2.4.3        ggridges_0.5.4        evaluate_0.18        \n [88] fastmap_1.1.0         goftest_1.2-3         yaml_2.3.5           \n [91] processx_3.7.0        knitr_1.40            fs_1.5.2             \n [94] fitdistrplus_1.1-8    purrr_0.3.4           RANN_2.6.1           \n [97] nlme_3.1-160          pbapply_1.6-0         future_1.29.0        \n[100] mime_0.12             brio_1.1.3            compiler_4.2.2       \n[103] rstudioapi_0.13       plotly_4.10.0         png_0.1-7            \n[106] spatstat.utils_3.0-1  tibble_3.1.7          stringi_1.7.6        \n[109] ps_1.7.0              desc_1.4.1            rgeos_0.5-9          \n[112] lattice_0.20-45       Matrix_1.5-1          vctrs_0.5.0          \n[115] pillar_1.8.1          lifecycle_1.0.3       spatstat.geom_3.0-3  \n[118] lmtest_0.9-40         GlobalOptions_0.1.2   RcppAnnoy_0.0.19     \n[121] data.table_1.14.2     cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    IRanges_2.31.2       \n[130] parallelly_1.32.1     sessioninfo_1.2.2     codetools_0.2-18     \n[133] MASS_7.3-58           assertthat_0.2.1      pkgload_1.3.0        \n[136] proto_1.0.0           rprojroot_2.0.3       rjson_0.2.21         \n[139] withr_2.5.0           SeuratObject_4.1.2    sctransform_0.3.5    \n[142] S4Vectors_0.35.0      mgcv_1.8-41           parallel_4.2.2       \n[145] rpart_4.1.19          tidyr_1.2.0           rmarkdown_2.17       \n[148] Rfast_2.0.6           Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/04_Data_exploration_clusters_id_patient8_NB.html",
    "href": "Crohn_disease/results/04_Data_exploration_clusters_id_patient8_NB.html",
    "title": "Data exploration patient 8",
    "section": "",
    "text": "today <- Sys.Date()\nformat(today, format = \"%A %d %B %Y\")\n\n[1] \"Wednesday 21 December 2022\"\n\n\n\nImport markers\n\nmarkers <- readxl::read_excel(\"../../Marker_genes.xlsx\",sheet = 1)\n\nNew names:\n• `` -> `...1`\n\nmarkers <- as.list(markers)\nmarkers <- markers[2:length(markers)]\nfor (nv in names(markers)) {\n  markers[[nv]] <- unique(markers[[nv]][!is.na(markers[[nv]])])\n}\n\n\n\nUninvolved ileum samples\n\nout_dir <- \"../../Crohn_disease/data/04_cluster_identification/\"\nin_dir <- \"../../Crohn_disease/data/02_cleaned_data/\"\nsample.id = \"patient8_Uninvolved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 255   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how much a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x-axis, there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\n\nSetting new log level to 1\n\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 39 detected over 42 genes\"\n[1] \"In Enterocytes there are 4 detected over 4 genes\"\n[1] \"In Goblet cells there are 5 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 3 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 5 detected over 5 genes\"\n[1] \"In Stem cells there are 2 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 4 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 5 detected over 11 genes\"\n[1] \"In ILC3 there are 5 detected over 6 genes\"\n[1] \"In Mast cells there are 2 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 4 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 4 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 3 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 4 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score isubpopulationesent in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 255 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detected in thex-axis,e.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         39       42\nEnterocytes                               4        4\nGoblet cells                              5        6\nEnteroendocrine cells                     0        4\nPaneth cells                              3        3\nTuft cells                                0        3\nTA cells                                  5        5\nStem cells                                2        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               4        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     5       11\nILC3                                      5        6\nMast cells                                2        6\nEndotelial Cells                          4        7\n??                                        0        2\nFibroblasts                               4        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               3        8\nEosinophil                                0        2\nBasophils                                 4        6\nISG                                     255      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nInvolved ileum samples\n\nsample.id = \"patient8_Involved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 266   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is different,tially expressed in the dataset. Genes expressed only in a sub-population of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 8 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 0 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 5 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 8 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 2 detected over 6 genes\"\n[1] \"In Mast cells there are 3 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 6 detected over 7 genes\"\n[1] \"In ?? there are 1 detected over 2 genes\"\n[1] \"In Fibroblasts there are 4 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 4 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 1 detected over 4 genes\"\n[1] \"In Neutrophils there are 3 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 3 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score if a gene is present in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 266 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detecx-axis the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          8       42\nEnterocytes                               0        4\nGoblet cells                              0        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  5        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           8        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     6       11\nILC3                                      2        6\nMast cells                                3        6\nEndotelial Cells                          6        7\n??                                        1        2\nFibroblasts                               4        6\nSmooth muscle cells                       4        5\nEnteric glia cells                        1        4\nNeutrophils                               3        8\nEosinophil                                0        2\nBasophils                                 3        6\nISG                                     266      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nPBMC samples\n\nsample.id = \"patient8_PBMC\"\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 215   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 1 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 0 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 3 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 1 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 9 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 1 detected over 6 genes\"\n[1] \"In Mast cells there are 0 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 2 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 0 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 1 detected over 4 genes\"\n[1] \"In Neutrophils there are 6 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 2 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score is a gene is present in more marker list)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 215 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how may are detected in the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          1       42\nEnterocytes                               0        4\nGoblet cells                              0        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           3        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              1        4\nDendridic Cells                           7        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                     9       11\nILC2s                                     6       11\nILC3                                      1        6\nMast cells                                0        6\nEndotelial Cells                          2        7\n??                                        0        2\nFibroblasts                               0        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        1        4\nNeutrophils                               6        8\nEosinophil                                0        2\nBasophils                                 2        6\nISG                                     215      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\nSession info\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    dendextend_1.16.0 stringr_1.4.0    \n[5] ggplot2_3.4.0     viridis_0.6.2     viridisLite_0.4.0 gridExtra_2.3    \n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       fansi_1.0.3           magrittr_2.0.3       \n [16] memoise_2.0.1         tensor_1.5            cluster_2.1.4        \n [19] doParallel_1.0.17     ROCR_1.0-11           remotes_2.4.2        \n [22] ComplexHeatmap_2.13.0 globals_0.16.2        matrixStats_0.63.0   \n [25] spatstat.sparse_3.0-0 prettyunits_1.1.1     colorspace_2.0-3     \n [28] ggrepel_0.9.2         xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            xtable_1.8-4          clue_0.3-61          \n [58] spatstat.core_2.4-4   reticulate_1.25       stats4_4.2.2         \n [61] htmlwidgets_1.5.4     httr_1.4.4            RColorBrewer_1.1-3   \n [64] ellipsis_0.3.2        Seurat_4.2.0          factoextra_1.0.7     \n [67] ica_1.0-2             farver_2.1.0          pkgconfig_2.0.3      \n [70] uwot_0.1.14           deldir_1.0-6          utf8_1.2.2           \n [73] labeling_0.4.2        tidyselect_1.2.0      rlang_1.0.6          \n [76] reshape2_1.4.4        later_1.3.0           cellranger_1.1.0     \n [79] munsell_0.5.0         tools_4.2.2           cachem_1.0.6         \n [82] cli_3.4.1             gsubfn_0.7            generics_0.1.2       \n [85] devtools_2.4.3        ggridges_0.5.4        evaluate_0.18        \n [88] fastmap_1.1.0         goftest_1.2-3         yaml_2.3.5           \n [91] processx_3.7.0        knitr_1.40            fs_1.5.2             \n [94] fitdistrplus_1.1-8    purrr_0.3.4           RANN_2.6.1           \n [97] nlme_3.1-160          pbapply_1.6-0         future_1.29.0        \n[100] mime_0.12             brio_1.1.3            compiler_4.2.2       \n[103] rstudioapi_0.13       plotly_4.10.0         png_0.1-7            \n[106] spatstat.utils_3.0-1  tibble_3.1.7          stringi_1.7.6        \n[109] ps_1.7.0              desc_1.4.1            rgeos_0.5-9          \n[112] lattice_0.20-45       Matrix_1.5-1          vctrs_0.5.0          \n[115] pillar_1.8.1          lifecycle_1.0.3       spatstat.geom_3.0-3  \n[118] lmtest_0.9-40         GlobalOptions_0.1.2   RcppAnnoy_0.0.19     \n[121] data.table_1.14.2     cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    IRanges_2.31.2       \n[130] parallelly_1.32.1     sessioninfo_1.2.2     codetools_0.2-18     \n[133] MASS_7.3-58           assertthat_0.2.1      pkgload_1.3.0        \n[136] proto_1.0.0           rprojroot_2.0.3       rjson_0.2.21         \n[139] withr_2.5.0           SeuratObject_4.1.2    sctransform_0.3.5    \n[142] S4Vectors_0.35.0      mgcv_1.8-41           parallel_4.2.2       \n[145] rpart_4.1.19          tidyr_1.2.0           rmarkdown_2.17       \n[148] Rfast_2.0.6           Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/04_Data_exploration_clusters_id_patient5_NB.html",
    "href": "Crohn_disease/results/04_Data_exploration_clusters_id_patient5_NB.html",
    "title": "Data exploration patient 5",
    "section": "",
    "text": "today <- Sys.Date()\nformat(today, format = \"%A %d %B %Y\")\n\n[1] \"Thursday 22 December 2022\"\n\n\n\nImport markers\n\nmarkers <- readxl::read_excel(\"../../Marker_genes.xlsx\",sheet = 1)\n\nNew names:\n• `` -> `...1`\n\nmarkers <- as.list(markers)\nmarkers <- markers[2:length(markers)]\nfor (nv in names(markers)) {\n  markers[[nv]] <- unique(markers[[nv]][!is.na(markers[[nv]])])\n}\n\n\n\nUninvolved ileum samples\n\nout_dir <- \"../../Crohn_disease/data/04_cluster_identification/\"\nin_dir <- \"../../Crohn_disease/data/02_cleaned_data/\"\nsample.id = \"patient5_Uninvolved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 203   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how much a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x-axis, there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\n\nSetting new log level to 1\n\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 21 detected over 42 genes\"\n[1] \"In Enterocytes there are 2 detected over 4 genes\"\n[1] \"In Goblet cells there are 1 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 3 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 6 detected over 8 genes\"\n[1] \"In Macrophages there are 4 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 6 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 4 detected over 6 genes\"\n[1] \"In Mast cells there are 4 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 4 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 3 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 4 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 3 detected over 4 genes\"\n[1] \"In Neutrophils there are 2 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 4 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score isubpopulationesent in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 203 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detected in thex-axis,e.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         21       42\nEnterocytes                               2        4\nGoblet cells                              1        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           3        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           6        8\nMacrophages                               4        5\nILCs - Cytotoxic natural killer           6        8\nILC1s                                    10       11\nILC2s                                     6       11\nILC3                                      4        6\nMast cells                                4        6\nEndotelial Cells                          4        7\n??                                        0        2\nFibroblasts                               3        6\nSmooth muscle cells                       4        5\nEnteric glia cells                        3        4\nNeutrophils                               2        8\nEosinophil                                0        2\nBasophils                                 4        6\nISG                                     203      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nInvolved ileum samples\n\nsample.id = \"patient5_Involved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 277   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is different,tially expressed in the dataset. Genes expressed only in a sub-population of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 6 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 0 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 1 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 5 detected over 5 genes\"\n[1] \"In Stem cells there are 3 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 3 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 7 detected over 11 genes\"\n[1] \"In ILC3 there are 5 detected over 6 genes\"\n[1] \"In Mast cells there are 3 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 6 detected over 7 genes\"\n[1] \"In ?? there are 1 detected over 2 genes\"\n[1] \"In Fibroblasts there are 5 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 5 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 5 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 3 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score if a gene is present in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 277 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detecx-axis the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          6       42\nEnterocytes                               0        4\nGoblet cells                              0        6\nEnteroendocrine cells                     1        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  5        5\nStem cells                                3        5\nBEST4 cells                               1        4\nRed blood genes                           3        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     7       11\nILC3                                      5        6\nMast cells                                3        6\nEndotelial Cells                          6        7\n??                                        1        2\nFibroblasts                               5        6\nSmooth muscle cells                       5        5\nEnteric glia cells                        2        4\nNeutrophils                               5        8\nEosinophil                                0        2\nBasophils                                 3        6\nISG                                     277      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nPBMC samples\n\nsample.id = \"patient5_PBMC\"\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 184   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 2 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 0 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 3 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 2 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 8 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 5 detected over 11 genes\"\n[1] \"In ILC3 there are 1 detected over 6 genes\"\n[1] \"In Mast cells there are 1 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 2 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 1 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 5 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 2 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score is a gene is present in more marker list)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 184 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how may are detected in the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          2       42\nEnterocytes                               0        4\nGoblet cells                              0        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           3        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              2        4\nDendridic Cells                           7        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           8        8\nILC1s                                    10       11\nILC2s                                     5       11\nILC3                                      1        6\nMast cells                                1        6\nEndotelial Cells                          2        7\n??                                        0        2\nFibroblasts                               1        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               5        8\nEosinophil                                0        2\nBasophils                                 2        6\nISG                                     184      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was longer than the number of\nclusters - first k elements are used\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\nSession info\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    dendextend_1.16.0 stringr_1.4.0    \n[5] ggplot2_3.4.0     viridis_0.6.2     viridisLite_0.4.0 gridExtra_2.3    \n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       fansi_1.0.3           magrittr_2.0.3       \n [16] memoise_2.0.1         tensor_1.5            cluster_2.1.4        \n [19] doParallel_1.0.17     ROCR_1.0-11           remotes_2.4.2        \n [22] ComplexHeatmap_2.13.0 globals_0.16.2        matrixStats_0.63.0   \n [25] spatstat.sparse_3.0-0 prettyunits_1.1.1     colorspace_2.0-3     \n [28] ggrepel_0.9.2         xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            xtable_1.8-4          clue_0.3-61          \n [58] spatstat.core_2.4-4   reticulate_1.25       stats4_4.2.2         \n [61] htmlwidgets_1.5.4     httr_1.4.4            RColorBrewer_1.1-3   \n [64] ellipsis_0.3.2        Seurat_4.2.0          factoextra_1.0.7     \n [67] ica_1.0-2             farver_2.1.0          pkgconfig_2.0.3      \n [70] uwot_0.1.14           deldir_1.0-6          utf8_1.2.2           \n [73] labeling_0.4.2        tidyselect_1.2.0      rlang_1.0.6          \n [76] reshape2_1.4.4        later_1.3.0           cellranger_1.1.0     \n [79] munsell_0.5.0         tools_4.2.2           cachem_1.0.6         \n [82] cli_3.4.1             gsubfn_0.7            generics_0.1.2       \n [85] devtools_2.4.3        ggridges_0.5.4        evaluate_0.18        \n [88] fastmap_1.1.0         goftest_1.2-3         yaml_2.3.5           \n [91] processx_3.7.0        knitr_1.40            fs_1.5.2             \n [94] fitdistrplus_1.1-8    purrr_0.3.4           RANN_2.6.1           \n [97] nlme_3.1-160          pbapply_1.6-0         future_1.29.0        \n[100] mime_0.12             brio_1.1.3            compiler_4.2.2       \n[103] rstudioapi_0.13       plotly_4.10.0         png_0.1-7            \n[106] spatstat.utils_3.0-1  tibble_3.1.7          stringi_1.7.6        \n[109] ps_1.7.0              desc_1.4.1            rgeos_0.5-9          \n[112] lattice_0.20-45       Matrix_1.5-1          vctrs_0.5.0          \n[115] pillar_1.8.1          lifecycle_1.0.3       spatstat.geom_3.0-3  \n[118] lmtest_0.9-40         GlobalOptions_0.1.2   RcppAnnoy_0.0.19     \n[121] data.table_1.14.2     cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    IRanges_2.31.2       \n[130] parallelly_1.32.1     sessioninfo_1.2.2     codetools_0.2-18     \n[133] MASS_7.3-58           assertthat_0.2.1      pkgload_1.3.0        \n[136] proto_1.0.0           rprojroot_2.0.3       rjson_0.2.21         \n[139] withr_2.5.0           SeuratObject_4.1.2    sctransform_0.3.5    \n[142] S4Vectors_0.35.0      mgcv_1.8-41           parallel_4.2.2       \n[145] rpart_4.1.19          tidyr_1.2.0           rmarkdown_2.17       \n[148] Rfast_2.0.6           Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/04_Data_exploration_clusters_id_patient12_NB.html",
    "href": "Crohn_disease/results/04_Data_exploration_clusters_id_patient12_NB.html",
    "title": "Data exploration patient 12",
    "section": "",
    "text": "today <- Sys.Date()\nformat(today, format = \"%A %d %B %Y\")\n\n[1] \"Wednesday 21 December 2022\"\n\n\n\nImport markers\n\nmarkers <- readxl::read_excel(\"../../Marker_genes.xlsx\",sheet = 1)\n\nNew names:\n• `` -> `...1`\n\nmarkers <- as.list(markers)\nmarkers <- markers[2:length(markers)]\nfor (nv in names(markers)) {\n  markers[[nv]] <- unique(markers[[nv]][!is.na(markers[[nv]])])\n}\n\n\n\nUninvolved ileum samples\n\nout_dir <- \"../../Crohn_disease/data/04_cluster_identification/\"\nin_dir <- \"../../Crohn_disease/data/02_cleaned_data/\"\nsample.id = \"patient12_Uninvolved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 242   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how much a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x-axis, there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\n\nSetting new log level to 1\n\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 27 detected over 42 genes\"\n[1] \"In Enterocytes there are 1 detected over 4 genes\"\n[1] \"In Goblet cells there are 2 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 3 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 5 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 4 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 6 detected over 8 genes\"\n[1] \"In ILC1s there are 9 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 6 detected over 6 genes\"\n[1] \"In Mast cells there are 5 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 6 detected over 7 genes\"\n[1] \"In ?? there are 2 detected over 2 genes\"\n[1] \"In Fibroblasts there are 3 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 4 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score isubpopulationesent in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 242 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detected in thex-axis,e.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         27       42\nEnterocytes                               1        4\nGoblet cells                              2        6\nEnteroendocrine cells                     0        4\nPaneth cells                              3        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              5        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               4        5\nILCs - Cytotoxic natural killer           6        8\nILC1s                                     9       11\nILC2s                                     6       11\nILC3                                      6        6\nMast cells                                5        6\nEndotelial Cells                          6        7\n??                                        2        2\nFibroblasts                               3        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               4        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     242      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nInvolved ileum samples\n\nsample.id = \"patient12_Involved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 269   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is different,tially expressed in the dataset. Genes expressed only in a sub-population of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 18 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 1 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 5 detected over 5 genes\"\n[1] \"In Stem cells there are 0 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 8 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 6 detected over 8 genes\"\n[1] \"In ILC1s there are 9 detected over 11 genes\"\n[1] \"In ILC2s there are 7 detected over 11 genes\"\n[1] \"In ILC3 there are 3 detected over 6 genes\"\n[1] \"In Mast cells there are 4 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 6 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 5 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 5 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 4 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score if a gene is present in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 269 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detecx-axis the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         18       42\nEnterocytes                               0        4\nGoblet cells                              1        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  5        5\nStem cells                                0        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           8        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           6        8\nILC1s                                     9       11\nILC2s                                     7       11\nILC3                                      3        6\nMast cells                                4        6\nEndotelial Cells                          6        7\n??                                        0        2\nFibroblasts                               5        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               5        8\nEosinophil                                0        2\nBasophils                                 4        6\nISG                                     269      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nPBMC samples\n\nsample.id = \"patient12_PBMC\"\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 261   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 7 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 1 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 2 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 8 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 8 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 7 detected over 11 genes\"\n[1] \"In ILC3 there are 3 detected over 6 genes\"\n[1] \"In Mast cells there are 1 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 2 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 2 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 7 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 4 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score is a gene is present in more marker list)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 261 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how may are detected in the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          7       42\nEnterocytes                               0        4\nGoblet cells                              1        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              2        4\nDendridic Cells                           8        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           8        8\nILC1s                                    10       11\nILC2s                                     7       11\nILC3                                      3        6\nMast cells                                1        6\nEndotelial Cells                          2        7\n??                                        0        2\nFibroblasts                               2        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               7        8\nEosinophil                                0        2\nBasophils                                 4        6\nISG                                     261      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\nSession info\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    dendextend_1.16.0 stringr_1.4.0    \n[5] ggplot2_3.4.0     viridis_0.6.2     viridisLite_0.4.0 gridExtra_2.3    \n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       fansi_1.0.3           magrittr_2.0.3       \n [16] memoise_2.0.1         tensor_1.5            cluster_2.1.4        \n [19] doParallel_1.0.17     ROCR_1.0-11           remotes_2.4.2        \n [22] ComplexHeatmap_2.13.0 globals_0.16.2        matrixStats_0.63.0   \n [25] spatstat.sparse_3.0-0 prettyunits_1.1.1     colorspace_2.0-3     \n [28] ggrepel_0.9.2         xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            xtable_1.8-4          clue_0.3-61          \n [58] spatstat.core_2.4-4   reticulate_1.25       stats4_4.2.2         \n [61] htmlwidgets_1.5.4     httr_1.4.4            RColorBrewer_1.1-3   \n [64] ellipsis_0.3.2        Seurat_4.2.0          factoextra_1.0.7     \n [67] ica_1.0-2             farver_2.1.0          pkgconfig_2.0.3      \n [70] uwot_0.1.14           deldir_1.0-6          utf8_1.2.2           \n [73] labeling_0.4.2        tidyselect_1.2.0      rlang_1.0.6          \n [76] reshape2_1.4.4        later_1.3.0           cellranger_1.1.0     \n [79] munsell_0.5.0         tools_4.2.2           cachem_1.0.6         \n [82] cli_3.4.1             gsubfn_0.7            generics_0.1.2       \n [85] devtools_2.4.3        ggridges_0.5.4        evaluate_0.18        \n [88] fastmap_1.1.0         goftest_1.2-3         yaml_2.3.5           \n [91] processx_3.7.0        knitr_1.40            fs_1.5.2             \n [94] fitdistrplus_1.1-8    purrr_0.3.4           RANN_2.6.1           \n [97] nlme_3.1-160          pbapply_1.6-0         future_1.29.0        \n[100] mime_0.12             brio_1.1.3            compiler_4.2.2       \n[103] rstudioapi_0.13       plotly_4.10.0         png_0.1-7            \n[106] spatstat.utils_3.0-1  tibble_3.1.7          stringi_1.7.6        \n[109] ps_1.7.0              desc_1.4.1            rgeos_0.5-9          \n[112] lattice_0.20-45       Matrix_1.5-1          vctrs_0.5.0          \n[115] pillar_1.8.1          lifecycle_1.0.3       spatstat.geom_3.0-3  \n[118] lmtest_0.9-40         GlobalOptions_0.1.2   RcppAnnoy_0.0.19     \n[121] data.table_1.14.2     cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    IRanges_2.31.2       \n[130] parallelly_1.32.1     sessioninfo_1.2.2     codetools_0.2-18     \n[133] MASS_7.3-58           assertthat_0.2.1      pkgload_1.3.0        \n[136] proto_1.0.0           rprojroot_2.0.3       rjson_0.2.21         \n[139] withr_2.5.0           SeuratObject_4.1.2    sctransform_0.3.5    \n[142] S4Vectors_0.35.0      mgcv_1.8-41           parallel_4.2.2       \n[145] rpart_4.1.19          tidyr_1.2.0           rmarkdown_2.17       \n[148] Rfast_2.0.6           Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/04_Data_exploration_clusters_id_patient14_NB.html",
    "href": "Crohn_disease/results/04_Data_exploration_clusters_id_patient14_NB.html",
    "title": "Data exploration patient 14",
    "section": "",
    "text": "today <- Sys.Date()\nformat(today, format = \"%A %d %B %Y\")\n\n[1] \"Friday 30 December 2022\"\n\n\n\nImport markers\n\nmarkers <- readxl::read_excel(\"../../Marker_genes.xlsx\",sheet = 1)\n\nNew names:\n• `` -> `...1`\n\nmarkers <- as.list(markers)\nmarkers <- markers[2:length(markers)]\nfor (nv in names(markers)) {\n  markers[[nv]] <- unique(markers[[nv]][!is.na(markers[[nv]])])\n}\n\n\n\nUninvolved ileum samples\n\nout_dir <- \"../../Crohn_disease/data/04_cluster_identification/\"\nin_dir <- \"../../Crohn_disease/data/02_cleaned_data/\"\nsample.id = \"patient14_Uninvolved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 261   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how much a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x-axis, there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\n\nSetting new log level to 1\n\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 30 detected over 42 genes\"\n[1] \"In Enterocytes there are 1 detected over 4 genes\"\n[1] \"In Goblet cells there are 2 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 3 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 3 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 0 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 5 detected over 6 genes\"\n[1] \"In Mast cells there are 4 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 6 detected over 7 genes\"\n[1] \"In ?? there are 1 detected over 2 genes\"\n[1] \"In Fibroblasts there are 5 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 5 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 3 detected over 4 genes\"\n[1] \"In Neutrophils there are 5 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score isubpopulationesent in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 261 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detected in thex-axis,e.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         30       42\nEnterocytes                               1        4\nGoblet cells                              2        6\nEnteroendocrine cells                     0        4\nPaneth cells                              3        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                3        5\nBEST4 cells                               1        4\nRed blood genes                           0        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     6       11\nILC3                                      5        6\nMast cells                                4        6\nEndotelial Cells                          6        7\n??                                        1        2\nFibroblasts                               5        6\nSmooth muscle cells                       5        5\nEnteric glia cells                        3        4\nNeutrophils                               5        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     261      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nInvolved ileum samples\n\nsample.id = \"patient14_Involved\"\n\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 247   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is different,tially expressed in the dataset. Genes expressed only in a sub-population of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 22 detected over 42 genes\"\n[1] \"In Enterocytes there are 1 detected over 4 genes\"\n[1] \"In Goblet cells there are 2 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 3 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 4 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 2 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 3 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 7 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 5 detected over 11 genes\"\n[1] \"In ILC3 there are 5 detected over 6 genes\"\n[1] \"In Mast cells there are 4 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 5 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 2 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 5 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 5 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score if a gene is present in more marker lists)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 247 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how many are detecx-axis the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                         22       42\nEnterocytes                               1        4\nGoblet cells                              2        6\nEnteroendocrine cells                     0        4\nPaneth cells                              3        3\nTuft cells                                0        3\nTA cells                                  4        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           2        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              3        4\nDendridic Cells                           7        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     5       11\nILC3                                      5        6\nMast cells                                4        6\nEndotelial Cells                          5        7\n??                                        0        2\nFibroblasts                               2        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               5        8\nEosinophil                                0        2\nBasophils                                 5        6\nISG                                     247      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\n\n\nPBMC samples\n\nsample.id = \"patient14_PBMC\"\nexpression.cl <- read.csv(paste0(out_dir,sample.id,\"_expression_clusters.csv\"),row.names = 1)\n\nobj <- readRDS(paste0(in_dir,sample.id,\".clustered.merged.cotan.RDS\"))\n\nISG.genes <- read.csv(\"../../ISG_fixed.txt\",header = T)\ncolnames(ISG.genes) <- \"genes\"\n\nNumber of ISG genes\n\ndim(ISG.genes)\n\n[1] 332   1\n\n\nDetected ISG genes in the sample\n\ndim(ISG.genes[ISG.genes$genes %in% getGenes(obj), ,drop = FALSE])\n\n[1] 253   1\n\n\n\nGDI plot with ISG genes\nGene Differentiation Index is a score of how mutch a gene is differentially expressed in the dataset. Genes expressed only in a subpopulation of cells will have a GDI score higher than 1.5 while constitutive genes will show a GDI lower than 1.5. In the plot on the x axis there is also an estimation of the mean gene expression in the whole sample.\n\nGDI.data <- calculateGDI(objCOTAN = obj)\nGDIPlot(objCOTAN = obj, \n        genes = list(\"High exp ISG\"=rownames(GDI.data[rownames(GDI.data) %in% \n                                  ISG.genes$genes &\n                                  GDI.data$sum.raw.norm >= 9,]),\n                          \"High GDI ISG\"=rownames(GDI.data[rownames(GDI.data) %in%\n                                                             ISG.genes$genes &\n                                  GDI.data$GDI >= quantile(GDI.data$GDI,probs = 0.99),])),\n        GDI.df = GDI.data)\n\n\n\n\nIn green the most expressed ISG genes and in purple the top GDI ISG genes in the sample. Red dotted line indicates the 1.5 GDI threshold for differentially expressed genes. The two blue lines indicate the firs and senonc quartile for GDI score.\n\n\n\n\n\n\nCluster assignment with expression increment\n\nscore.df <- geneSetEnrichment(objCOTAN = obj,\n                              genes = markers, \n                              expression.cl = expression.cl)\n\n[1] \"In Epithelial genes there are 3 detected over 42 genes\"\n[1] \"In Enterocytes there are 0 detected over 4 genes\"\n[1] \"In Goblet cells there are 0 detected over 6 genes\"\n[1] \"In Enteroendocrine cells there are 0 detected over 4 genes\"\n[1] \"In Paneth cells there are 1 detected over 3 genes\"\n[1] \"In Tuft cells there are 0 detected over 3 genes\"\n[1] \"In TA cells there are 2 detected over 5 genes\"\n[1] \"In Stem cells there are 1 detected over 5 genes\"\n[1] \"In BEST4 cells there are 1 detected over 4 genes\"\n[1] \"In Red blood genes there are 3 detected over 3 genes\"\n[1] \"In T cell genes there are 6 detected over 6 genes\"\n[1] \"In B cell genes there are 6 detected over 6 genes\"\n[1] \"In Plasma Cells there are 2 detected over 4 genes\"\n[1] \"In Dendridic Cells there are 8 detected over 8 genes\"\n[1] \"In Macrophages there are 5 detected over 5 genes\"\n[1] \"In ILCs - Cytotoxic natural killer there are 7 detected over 8 genes\"\n[1] \"In ILC1s there are 10 detected over 11 genes\"\n[1] \"In ILC2s there are 6 detected over 11 genes\"\n[1] \"In ILC3 there are 2 detected over 6 genes\"\n[1] \"In Mast cells there are 1 detected over 6 genes\"\n[1] \"In Endotelial Cells there are 2 detected over 7 genes\"\n[1] \"In ?? there are 0 detected over 2 genes\"\n[1] \"In Fibroblasts there are 1 detected over 6 genes\"\n[1] \"In Smooth muscle cells there are 3 detected over 5 genes\"\n[1] \"In Enteric glia cells there are 2 detected over 4 genes\"\n[1] \"In Neutrophils there are 6 detected over 8 genes\"\n[1] \"In Eosinophil there are 0 detected over 2 genes\"\n[1] \"In Basophils there are 4 detected over 6 genes\"\n\n\nWe add separately the ISG score (to avoid the division of the score is a gene is present in more marker list)\n\nscore.ISG <- geneSetEnrichment(objCOTAN = obj,\n                              genes = list(\"ISG\"=ISG.genes$genes), \n                              expression.cl = expression.cl)\n\n[1] \"In ISG there are 253 detected over 332 genes\"\n\nscore.df <- rbind(score.df,score.ISG)\n\nIn the next table we can observe how many marker genes we defined and how may are detected in the sample.\n\nscore.df[,c(\"N. detected\",\"N. total\")]\n\n                                N. detected N. total\nEpithelial genes                          3       42\nEnterocytes                               0        4\nGoblet cells                              0        6\nEnteroendocrine cells                     0        4\nPaneth cells                              1        3\nTuft cells                                0        3\nTA cells                                  2        5\nStem cells                                1        5\nBEST4 cells                               1        4\nRed blood genes                           3        3\nT cell genes                              6        6\nB cell genes                              6        6\nPlasma Cells                              2        4\nDendridic Cells                           8        8\nMacrophages                               5        5\nILCs - Cytotoxic natural killer           7        8\nILC1s                                    10       11\nILC2s                                     6       11\nILC3                                      2        6\nMast cells                                1        6\nEndotelial Cells                          2        7\n??                                        0        2\nFibroblasts                               1        6\nSmooth muscle cells                       3        5\nEnteric glia cells                        2        4\nNeutrophils                               6        8\nEosinophil                                0        2\nBasophils                                 4        6\nISG                                     253      332\n\n\nCluster tree using the cosine distance over cluster coex.\n\ncluster_data <- getClusterizationData(obj)[[\"coex\"]]\n\n######## This is the best: cosine dissimilarity\nMatrix <- as.matrix(t(cluster_data))\nsim <- Matrix / sqrt(rowSums(Matrix * Matrix))\nsim <- sim %*% t(sim)\nD_sim <- as.dist(1 - sim)\ntree <- hclust(D_sim,method = \"ward.D2\")\n\n\n\nWarning in get_col(col, k): Length of color vector was shorter than the number\nof clusters - color vector was recycled\n\n\n\n\n\n\n\n\n\n\nFinal score heatmap\n\ncol_fun = colorRamp2(c(0, 1), c( \"lightblue\", \"red\"))\nfinal.heatmap <- Heatmap(df.t, rect_gp = gpar(col = \"white\", lwd = 1),\n        #cluster_rows = F,\n        cluster_columns = FALSE,\n        show_heatmap_legend = F,\n        col = col_fun,\n        width =  unit(28, \"cm\"),\n        row_dend_width = unit(8, \"cm\"),\n        #height = unit(6, \"cm\"),\n        cluster_rows = dend,\n        column_names_gp = gpar(fontsize = 11),\n      row_names_gp = gpar(fontsize = 9),\n        cell_fun = function(j, i, x, y, width, height, fill) {\n        grid.text(sprintf(\"%.1f\", df.t[i, j]), x, y, gp = gpar(fontsize = 9))\n},\nright_annotation = ha,\nleft_annotation = hb\n)\n\nfinal.heatmap\n\n\n\n\n\nsaveRDS(final.heatmap,paste0(\"../../Crohn_disease/data/04_cluster_identification/\",sample.id,\"_heatmap.RDS\"))\n\n\nSession info\n\nsessionInfo()\n\nR version 4.2.2 Patched (2022-11-10 r83330)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 20.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\nattached base packages:\n[1] grid      stats     graphics  grDevices utils     datasets  methods  \n[8] base     \n\nother attached packages:\n[1] COTAN_2.0.0       testthat_3.1.6    dendextend_1.16.0 stringr_1.4.0    \n[5] ggplot2_3.4.0     viridis_0.6.2     viridisLite_0.4.0 gridExtra_2.3    \n\nloaded via a namespace (and not attached):\n  [1] readxl_1.4.0          circlize_0.4.15       plyr_1.8.7           \n  [4] igraph_1.3.4          lazyeval_0.2.2        sp_1.5-0             \n  [7] splines_4.2.2         listenv_0.8.0         scattermore_0.8      \n [10] usethis_2.1.6         digest_0.6.29         foreach_1.5.2        \n [13] htmltools_0.5.2       fansi_1.0.3           magrittr_2.0.3       \n [16] memoise_2.0.1         tensor_1.5            cluster_2.1.4        \n [19] doParallel_1.0.17     ROCR_1.0-11           remotes_2.4.2        \n [22] ComplexHeatmap_2.13.0 globals_0.16.2        matrixStats_0.63.0   \n [25] spatstat.sparse_3.0-0 prettyunits_1.1.1     colorspace_2.0-3     \n [28] ggrepel_0.9.2         xfun_0.31             dplyr_1.0.9          \n [31] callr_3.7.0           crayon_1.5.1          jsonlite_1.8.0       \n [34] spatstat.data_3.0-0   progressr_0.11.0      survival_3.4-0       \n [37] zoo_1.8-10            iterators_1.0.14      glue_1.6.2           \n [40] polyclip_1.10-0       gtable_0.3.0          leiden_0.4.2         \n [43] GetoptLong_1.0.5      pkgbuild_1.4.0        RcppZiggurat_0.1.6   \n [46] future.apply_1.10.0   shape_1.4.6           BiocGenerics_0.43.0  \n [49] abind_1.4-5           scales_1.2.0          DBI_1.1.3            \n [52] ggthemes_4.2.4        spatstat.random_3.0-1 miniUI_0.1.1.1       \n [55] Rcpp_1.0.9            xtable_1.8-4          clue_0.3-61          \n [58] spatstat.core_2.4-4   reticulate_1.25       stats4_4.2.2         \n [61] htmlwidgets_1.5.4     httr_1.4.4            RColorBrewer_1.1-3   \n [64] ellipsis_0.3.2        Seurat_4.2.0          factoextra_1.0.7     \n [67] ica_1.0-2             farver_2.1.0          pkgconfig_2.0.3      \n [70] uwot_0.1.14           deldir_1.0-6          utf8_1.2.2           \n [73] labeling_0.4.2        tidyselect_1.2.0      rlang_1.0.6          \n [76] reshape2_1.4.4        later_1.3.0           cellranger_1.1.0     \n [79] munsell_0.5.0         tools_4.2.2           cachem_1.0.6         \n [82] cli_3.4.1             gsubfn_0.7            generics_0.1.2       \n [85] devtools_2.4.3        ggridges_0.5.4        evaluate_0.18        \n [88] fastmap_1.1.0         goftest_1.2-3         yaml_2.3.5           \n [91] processx_3.7.0        knitr_1.40            fs_1.5.2             \n [94] fitdistrplus_1.1-8    purrr_0.3.4           RANN_2.6.1           \n [97] nlme_3.1-160          pbapply_1.6-0         future_1.29.0        \n[100] mime_0.12             brio_1.1.3            compiler_4.2.2       \n[103] rstudioapi_0.13       plotly_4.10.0         png_0.1-7            \n[106] spatstat.utils_3.0-1  tibble_3.1.7          stringi_1.7.6        \n[109] ps_1.7.0              desc_1.4.1            rgeos_0.5-9          \n[112] lattice_0.20-45       Matrix_1.5-1          vctrs_0.5.0          \n[115] pillar_1.8.1          lifecycle_1.0.3       spatstat.geom_3.0-3  \n[118] lmtest_0.9-40         GlobalOptions_0.1.2   RcppAnnoy_0.0.19     \n[121] data.table_1.14.2     cowplot_1.1.1         irlba_2.3.5.1        \n[124] httpuv_1.6.5          patchwork_1.1.1       R6_2.5.1             \n[127] promises_1.2.0.1      KernSmooth_2.23-20    IRanges_2.31.2       \n[130] parallelly_1.32.1     sessioninfo_1.2.2     codetools_0.2-18     \n[133] MASS_7.3-58           assertthat_0.2.1      pkgload_1.3.0        \n[136] proto_1.0.0           rprojroot_2.0.3       rjson_0.2.21         \n[139] withr_2.5.0           SeuratObject_4.1.2    sctransform_0.3.5    \n[142] S4Vectors_0.35.0      mgcv_1.8-41           parallel_4.2.2       \n[145] rpart_4.1.19          tidyr_1.2.0           rmarkdown_2.17       \n[148] Rfast_2.0.6           Rtsne_0.16            shiny_1.7.1"
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html",
    "title": "Final report - heatmap summary",
    "section": "",
    "text": "today <- Sys.Date()\nformat(today, format = \"%A %d %B %Y\")\n\n[1] \"Friday 23 December 2022\""
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#instruction-how-to-read-the-plots",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#instruction-how-to-read-the-plots",
    "title": "Final report - heatmap summary",
    "section": "Instruction: how to read the plots",
    "text": "Instruction: how to read the plots\nThe following plots are the same present in the end of each analysis, reported here to have a better overview.\nEach plot is composed of a heatmap with an enrichement score (from 0 to 1) for each marker gene set in each cell cluster. The cell cluster number is indicated for each row with roman number in the rightmost column. For the marker score, if a gene is considered a marker for more than one group, the score is proportionally reduced. The last column of the heatmap contains the score for the ISG set of genes. On the left there is a dendrogram evaluated using a distance (cosine) over all COTAN uniform clusters and considering, to estimate the distance, the whole transcriptome. The green bar plot between the dendrogram and the heatmap shows the UMI detection efficiency (UDE) mean. This score is the RNA extraction efficiency mean for the cell cluster. This can be usefull because if we observe a very low UDE and no clear marker group enrichment or there is an enrichment for more than one marker set (and very different), is it possible that the cluster is formed by just background signal. The right orange bar plot shows the cluster cell number."
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-5",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-5",
    "title": "Final report - heatmap summary",
    "section": "Patient 5",
    "text": "Patient 5\n\n\nLoading required package: viridisLite\n\n\n\n---------------------\nWelcome to dendextend version 1.16.0\nType citation('dendextend') for how to cite the package.\n\nType browseVignettes(package = 'dendextend') for the package vignette.\nThe github page is: https://github.com/talgalili/dendextend/\n\nSuggestions and bug-reports can be submitted at: https://github.com/talgalili/dendextend/issues\nYou may ask questions at stackoverflow, use the r and dendextend tags: \n     https://stackoverflow.com/questions/tagged/dendextend\n\n    To suppress this message use:  suppressPackageStartupMessages(library(dendextend))\n---------------------\n\n\n\nAttaching package: 'dendextend'\n\n\nThe following object is masked from 'package:stats':\n\n    cutree\n\n\n\ninvolved5\n\n\n\n\nInvolved sample for patient 5\n\n\n\n\n\nuninvolved5\n\n\n\n\nUninvolved sample for patient 5\n\n\n\n\n\nPBMC5\n\n\n\n\nPBMC sample for patient 5"
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-7",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-7",
    "title": "Final report - heatmap summary",
    "section": "Patient 7",
    "text": "Patient 7\n\n\n\n\ninvolved7\n\n\n\n\nInvolved sample for patient 7\n\n\n\n\n\nuninvolved7\n\n\n\n\nUninvolved sample for patient 7\n\n\n\n\n\nPBMC7\n\n\n\n\nPBMC sample for patient 7"
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-8",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-8",
    "title": "Final report - heatmap summary",
    "section": "Patient 8",
    "text": "Patient 8\n\n\n\n\ninvolved8\n\n\n\n\nInvolved sample for patient 8\n\n\n\n\n\nuninvolved8\n\n\n\n\nUninvolved sample for patient 8\n\n\n\n\n\nPBMC8\n\n\n\n\nPBMC sample for patient 8"
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-10",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-10",
    "title": "Final report - heatmap summary",
    "section": "Patient 10",
    "text": "Patient 10\n\n\n\n\ninvolved10\n\n\n\n\nInvolved sample for patient 10\n\n\n\n\n\nuninvolved10\n\n\n\n\nUninvolved sample for patient 10\n\n\n\n\n\nPBMC10\n\n\n\n\nPBMC sample for patient 10"
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-11",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-11",
    "title": "Final report - heatmap summary",
    "section": "Patient 11",
    "text": "Patient 11\n\n\n\n\ninvolved11\n\n\n\n\nInvolved sample for patient 11\n\n\n\n\n\nuninvolved11\n\n\n\n\nUninvolved sample for patient 11\n\n\n\n\n\nPBMC11\n\n\n\n\nPBMC sample for patient 11"
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-12",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#patient-12",
    "title": "Final report - heatmap summary",
    "section": "Patient 12",
    "text": "Patient 12\n\n\n\n\ninvolved12\n\n\n\n\nInvolved sample for patient 12\n\n\n\n\n\nuninvolved12\n\n\n\n\nUninvolved sample for patient 12\n\n\n\n\n\nPBMC12\n\n\n\n\nPBMC sample for patient 12"
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#univolved",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#univolved",
    "title": "Final report - heatmap summary",
    "section": "Univolved",
    "text": "Univolved\n\nuninvolved5\n\n\n\n\n\nuninvolved7\n\n\n\n\n\nuninvolved8\n\n\n\n\n\nuninvolved10\n\n\n\n\n\nuninvolved11\n\n\n\n\n\nuninvolved12\n\n\n\n\nGenerally in the univolved samples the ISG set seems to be enriched always in a Endothelial, Fibroblast or Smooth muscle cell group or in another Dendridic, Macrophage cell group."
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#involved",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#involved",
    "title": "Final report - heatmap summary",
    "section": "Involved",
    "text": "Involved\n\ninvolved5\n\n\n\n\n\ninvolved7\n\n\n\n\n\ninvolved8\n\n\n\n\n\ninvolved10\n\n\n\n\n\ninvolved11\n\n\n\n\n\ninvolved12\n\n\n\n\nIn the involved samples with the previous groups enriched in ISG genes, we can also observe and involvement in the T cells/ILC. Only in patient 10, in which we observe some epithelial cells left, we see also here an ISG enrichment."
  },
  {
    "objectID": "Crohn_disease/results/05_HeatmapSummary_NB.html#pbmc",
    "href": "Crohn_disease/results/05_HeatmapSummary_NB.html#pbmc",
    "title": "Final report - heatmap summary",
    "section": "PBMC",
    "text": "PBMC\n\nPBMC5\n\n\n\n\n\nPBMC7\n\n\n\n\n\nPBMC8\n\n\n\n\n\nPBMC10\n\n\n\n\n\nPBMC11\n\n\n\n\n\nPBMC12\n\n\n\n\nIn this type of samples the ISG groups seems less expressed with again the involvement of macrophages/dendritic cells but also, in some cases the cytotoxic natural killer"
  }
]